[
    {
        "name": "roman_to_integer",
        "url": "https://leetcode.cn/problems/roman-to-integer/description",
        "title": "13. 罗马数字转整数 - 力扣（LeetCode）",
        "content": "# 13. 罗马数字转整数 - 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n# 字符          数值# I             1# V             5# X             10# L             50# C             100# D             500# M             1000# 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n# 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n#  * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n#  * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n#  * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n# 给定一个罗马数字，将其转换成整数。# 示例 1:# 输入: s = \"III\"# 输出: 3# 示例 2:# 输入: s = \"IV\"# 输出: 4# 示例 3:# 输入: s = \"IX\"# 输出: 9# 示例 4:# 输入: s = \"LVIII\"# 输出: 58# 解释: L = 50, V= 5, III = 3.\n# 示例 5:# 输入: s = \"MCMXCIV\"# 输出: 1994# 解释: M = 1000, CM = 900, XC = 90, IV = 4.\n# 提示：#  * 1 <= s.length <= 15#  * s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')\n#  * 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内\n#  * 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n#  * IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n#  * 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics [https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article]。\n"
    },
    {
        "name": "integer_to_roman",
        "url": "https://leetcode.cn/problems/integer-to-roman/description",
        "title": "12. 整数转罗马数字 - 力扣（LeetCode）",
        "content": "# 12. 整数转罗马数字 - 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n# 字符          数值# I             1# V             5# X             10# L             50# C             100# D             500# M             1000# 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n# 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n#  * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n#  * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n#  * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n# 给你一个整数，将其转为罗马数字。# 示例 1:# 输入: num = 3# 输出: \"III\"# 示例 2:# 输入: num = 4# 输出: \"IV\"# 示例 3:# 输入: num = 9# 输出: \"IX\"# 示例 4:# 输入: num = 58# 输出: \"LVIII\"# 解释: L = 50, V = 5, III = 3.\n# 示例 5:# 输入: num = 1994# 输出: \"MCMXCIV\"# 解释: M = 1000, CM = 900, XC = 90, IV = 4.\n# 提示：#  * 1 <= num <= 3999"
    },
    {
        "name": "length_of_last_word",
        "url": "https://leetcode.cn/problems/length-of-last-word/description",
        "title": "58. 最后一个单词的长度 - 力扣（LeetCode）",
        "content": "# 58. 最后一个单词的长度 - 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n# 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n# 示例 1：# 输入：s = \"Hello World\"# 输出：5# 解释：最后一个单词是“World”，长度为5。# 示例 2：# 输入：s = \"   fly me   to   the moon  \"\n# 输出：4# 解释：最后一个单词是“moon”，长度为4。# 示例 3：# 输入：s = \"luffy is still joyboy\"\n# 输出：6# 解释：最后一个单词是长度为6的“joyboy”。\n# 提示：#  * 1 <= s.length <= 104#  * s 仅有英文字母和空格 ' ' 组成#  * s 中至少存在一个单词"
    },
    {
        "name": "longest_common_prefix",
        "url": "https://leetcode.cn/problems/longest-common-prefix/description",
        "title": "14. 最长公共前缀 - 力扣（LeetCode）",
        "content": "# 14. 最长公共前缀 - 编写一个函数来查找字符串数组中的最长公共前缀。\n# 如果不存在公共前缀，返回空字符串 \"\"。# 示例 1：# 输入：strs = [\"flower\",\"flow\",\"flight\"]\n# 输出：\"fl\"# 示例 2：# 输入：strs = [\"dog\",\"racecar\",\"car\"]\n# 输出：\"\"# 解释：输入不存在公共前缀。# 提示：#  * 1 <= strs.length <= 200\n#  * 0 <= strs[i].length <= 200\n#  * strs[i] 仅由小写英文字母组成"
    },
    {
        "name": "reverse_words_in_a_string",
        "url": "https://leetcode.cn/problems/reverse-words-in-a-string/description",
        "title": "151. 反转字符串中的单词 - 力扣（LeetCode）",
        "content": "# 151. 反转字符串中的单词 - 给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n# 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n# 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n# 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n# 示例 1：# 输入：s = \"the sky is blue\"\n# 输出：\"blue is sky the\"# 示例 2：# 输入：s = \"  hello world  \"\n# 输出：\"world hello\"# 解释：反转后的字符串中不能存在前导空格和尾随空格。\n# 示例 3：# 输入：s = \"a good   example\"\n# 输出：\"example good a\"# 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n# 提示：#  * 1 <= s.length <= 104#  * s 包含英文大小写字母、数字和空格 ' '\n#  * s 中 至少存在一个 单词# 进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n"
    },
    {
        "name": "zigzag_conversion",
        "url": "https://leetcode.cn/problems/zigzag-conversion/description",
        "title": "6. Z 字形变换 - 力扣（LeetCode）",
        "content": "# 6. Z 字形变换 - 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n# 比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下：\n# P   A   H   N# A P L S I I G# Y   I   R# 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。\n# 请你实现这个将字符串进行指定行数变换的函数：# string convert(string s, int numRows);\n# 示例 1：# 输入：s = \"PAYPALISHIRING\", numRows = 3\n# 输出：\"PAHNAPLSIIGYIR\"# 示例 2：# 输入：s = \"PAYPALISHIRING\", numRows = 4\n# 输出：\"PINALSIGYAHRPI\"# 解释：# P     I    N# A   L S  I G# Y A   H R# P     I# 示例 3：# 输入：s = \"A\", numRows = 1# 输出：\"A\"# 提示：#  * 1 <= s.length <= 1000\n#  * s 由英文字母（小写和大写）、',' 和 '.' 组成\n#  * 1 <= numRows <= 1000"
    },
    {
        "name": "find_the_index_of_the_first_occurrence_in_a_string",
        "url": "https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description",
        "title": "28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）",
        "content": "# 28. 找出字符串中第一个匹配项的下标 - 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。\n# 示例 1：# 输入：haystack = \"sadbutsad\", needle = \"sad\"\n# 输出：0# 解释：\"sad\" 在下标 0 和 6 处匹配。# 第一个匹配项的下标是 0 ，所以返回 0 。# 示例 2：# 输入：haystack = \"leetcode\", needle = \"leeto\"\n# 输出：-1# 解释：\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。\n# 提示：#  * 1 <= haystack.length, needle.length <= 104\n#  * haystack 和 needle 仅由小写英文字符组成\n"
    },
    {
        "name": "text_justification",
        "url": "https://leetcode.cn/problems/text-justification/description",
        "title": "68. 文本左右对齐 - 力扣（LeetCode）",
        "content": "# 68. 文本左右对齐 - 给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。\n# 你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。\n# 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。\n# 文本的最后一行应为左对齐，且单词之间不插入额外的空格。\n# 注意:#  * 单词是指由非空格字符组成的字符序列。#  * 每个单词的长度大于 0，小于等于 maxWidth。\n#  * 输入单词数组 words 至少包含一个单词。\n# 示例 1:# 输入: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n# 输出:# [#    \"This    is    an\",#    \"example  of text\",#    \"justification.  \"# ]# 示例 2:# 输入:words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n# 输出:# [#   \"What   must   be\",#   \"acknowledgment  \",#   \"shall be        \"# ]# 解释: 注意最后一行的格式应为 \"shall be    \" 而不是 \"shall     be\",\n#      因为最后一行应为左对齐，而不是左右两端对齐。       \n#      第二行同样为左对齐，这是因为这行只包含一个单词。\n# 示例 3:# 输入:words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]，maxWidth = 20\n# 输出:# [#   \"Science  is  what we\",\n#   \"understand      well\",\n#   \"enough to explain to\",\n#   \"a  computer.  Art is\",\n#   \"everything  else  we\",\n#   \"do                  \"\n# ]# 提示:#  * 1 <= words.length <= 300\n#  * 1 <= words[i].length <= 20\n#  * words[i] 由小写英文字母和符号组成\n#  * 1 <= maxWidth <= 100#  * words[i].length <= maxWidth\n"
    },
    {
        "name": "valid_palindrome",
        "url": "https://leetcode.cn/problems/valid-palindrome/description",
        "title": "125. 验证回文串 - 力扣（LeetCode）",
        "content": "# 125. 验证回文串 - 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。\n# 字母和数字都属于字母数字字符。# 给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。\n# 示例 1：# 输入: s = \"A man, a plan, a canal: Panama\"\n# 输出：true# 解释：\"amanaplanacanalpanama\" 是回文串。\n# 示例 2：# 输入：s = \"race a car\"# 输出：false# 解释：\"raceacar\" 不是回文串。# 示例 3：# 输入：s = \" \"# 输出：true# 解释：在移除非字母数字字符之后，s 是一个空字符串 \"\" 。\n# 由于空字符串正着反着读都一样，所以是回文串。# 提示：#  * 1 <= s.length <= 2 * 105\n#  * s 仅由可打印的 ASCII 字符组成"
    },
    {
        "name": "is_subsequence",
        "url": "https://leetcode.cn/problems/is-subsequence/description",
        "title": "392. 判断子序列 - 力扣（LeetCode）",
        "content": "# 392. 判断子序列 - 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n# 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n# 进阶：# 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n# 致谢：# 特别感谢 @pbrother  [https://leetcode.com/pbrother/]添加此问题并且创建所有测试用例。\n# 示例 1：# 输入：s = \"abc\", t = \"ahbgdc\"\n# 输出：true# 示例 2：# 输入：s = \"axc\", t = \"ahbgdc\"\n# 输出：false# 提示：#  * 0 <= s.length <= 100#  * 0 <= t.length <= 10^4\n#  * 两个字符串都只由小写字符组成。"
    },
    {
        "name": "two_sum_ii_input_array_is_sorted",
        "url": "https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description",
        "title": "167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）",
        "content": "# 167. 两数之和 II - 输入有序数组 - 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n# 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n# 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n# 你所设计的解决方案必须只使用常量级的额外空间。# 示例 1：# 输入：numbers = [2,7,11,15], target = 9\n# 输出：[1,2]# 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n# 示例 2：# 输入：numbers = [2,3,4], target = 6\n# 输出：[1,3]# 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n# 示例 3：# 输入：numbers = [-1,0], target = -1\n# 输出：[1,2]# 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n# 提示：#  * 2 <= numbers.length <= 3 * 104\n#  * -1000 <= numbers[i] <= 1000\n#  * numbers 按 非递减顺序 排列#  * -1000 <= target <= 1000\n#  * 仅存在一个有效答案"
    },
    {
        "name": "container_with_most_water",
        "url": "https://leetcode.cn/problems/container-with-most-water/description",
        "title": "11. 盛最多水的容器 - 力扣（LeetCode）",
        "content": "# 11. 盛最多水的容器 - 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n# 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n# 返回容器可以储存的最大水量。# 说明：你不能倾斜容器。# 示例 1：# [https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg]\n# 输入：[1,8,6,2,5,4,8,3,7]# 输出：49 # 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n# 示例 2：# 输入：height = [1,1]# 输出：1# 提示：#  * n == height.length#  * 2 <= n <= 105#  * 0 <= height[i] <= 104\n"
    },
    {
        "name": "3sum",
        "url": "https://leetcode.cn/problems/3sum/description",
        "title": "15. 三数之和 - 力扣（LeetCode）",
        "content": "# 15. 三数之和 - 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n# 你返回所有和为 0 且不重复的三元组。# 注意：答案中不可以包含重复的三元组。# 示例 1：# 输入：nums = [-1,0,1,2,-1,-4]\n# 输出：[[-1,-1,2],[-1,0,1]]# 解释：# nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\n# nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\n# nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n# 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n# 注意，输出的顺序和三元组的顺序并不重要。# 示例 2：# 输入：nums = [0,1,1]# 输出：[]# 解释：唯一可能的三元组和不为 0 。# 示例 3：# 输入：nums = [0,0,0]# 输出：[[0,0,0]]# 解释：唯一可能的三元组和为 0 。# 提示：#  * 3 <= nums.length <= 3000\n#  * -105 <= nums[i] <= 105\n"
    },
    {
        "name": "minimum_size_subarray_sum",
        "url": "https://leetcode.cn/problems/minimum-size-subarray-sum/description",
        "title": "209. 长度最小的子数组 - 力扣（LeetCode）",
        "content": "# 209. 长度最小的子数组 - 给定一个含有 n 个正整数的数组和一个正整数 target 。\n# 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n# 示例 1：# 输入：target = 7, nums = [2,3,1,2,4,3]\n# 输出：2# 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n# 示例 2：# 输入：target = 4, nums = [1,4,4]\n# 输出：1# 示例 3：# 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n# 输出：0# 提示：#  * 1 <= target <= 109#  * 1 <= nums.length <= 105\n#  * 1 <= nums[i] <= 105# 进阶：#  * 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\n"
    },
    {
        "name": "longest_substring_without_repeating_characters",
        "url": "https://leetcode.cn/problems/longest-substring-without-repeating-characters/description",
        "title": "3. 无重复字符的最长子串 - 力扣（LeetCode）",
        "content": "# 3. 无重复字符的最长子串 - 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n# 示例 1:# 输入: s = \"abcabcbb\"# 输出: 3 # 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n# 示例 2:# 输入: s = \"bbbbb\"# 输出: 1# 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n# 示例 3:# 输入: s = \"pwwkew\"# 输出: 3# 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n#      请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n# 提示：#  * 0 <= s.length <= 5 * 104\n#  * s 由英文字母、数字、符号和空格组成"
    },
    {
        "name": "substring_with_concatenation_of_all_words",
        "url": "https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description",
        "title": "30. 串联所有单词的子串 - 力扣（LeetCode）",
        "content": "# 30. 串联所有单词的子串 - 给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\n#  s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。\n#  * 例如，如果 words = [\"ab\",\"cd\",\"ef\"]， 那么 \"abcdef\"， \"abefcd\"，\"cdabef\"， \"cdefab\"，\"efabcd\"， 和 \"efcdab\" 都是串联子串。 \"acdbef\" 不是串联子串，因为他不是任何 words 排列的连接。\n# 返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。\n# 示例 1：# 输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n# 输出：[0,9]# 解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n# 子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n# 子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n# 输出顺序无关紧要。返回 [9,0] 也是可以的。\n# 示例 2：# 输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n# 输出：[]# 解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\n# s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n# 所以我们返回一个空数组。# 示例 3：# 输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n# 输出：[6,9,12]# 解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n# 子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n# 子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n# 子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。\n# 提示：#  * 1 <= s.length <= 104#  * 1 <= words.length <= 5000\n#  * 1 <= words[i].length <= 30\n#  * words[i] 和 s 由小写英文字母组成\n"
    },
    {
        "name": "minimum_window_substring",
        "url": "https://leetcode.cn/problems/minimum-window-substring/description",
        "title": "76. 最小覆盖子串 - 力扣（LeetCode）",
        "content": "# 76. 最小覆盖子串 - 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。\n# 注意：#  * 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。\n#  * 如果 s 中存在这样的子串，我们保证它是唯一的答案。\n# 示例 1：# 输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n# 输出：\"BANC\"# 解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n# 示例 2：# 输入：s = \"a\", t = \"a\"# 输出：\"a\"# 解释：整个字符串 s 是最小覆盖子串。# 示例 3:# 输入: s = \"a\", t = \"aa\"# 输出: \"\"# 解释: t 中两个字符 'a' 均应包含在 s 的子串中，\n# 因此没有符合条件的子字符串，返回空字符串。# 提示：#  * m == s.length#  * n == t.length#  * 1 <= m, n <= 105#  * s 和 t 由英文字母组成# 进阶：你能设计一个在 o(m+n) 时间内解决此问题的算法吗？\n"
    },
    {
        "name": "valid_sudoku",
        "url": "https://leetcode.cn/problems/valid-sudoku/description",
        "title": "36. 有效的数独 - 力扣（LeetCode）",
        "content": "# 36. 有效的数独 - 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。\n#  1. 数字 1-9 在每一行只能出现一次。#  2. 数字 1-9 在每一列只能出现一次。#  3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n# 注意：#  * 一个有效的数独（部分已被填充）不一定是可解的。\n#  * 只需要根据以上规则，验证已经填入的数字是否有效即可。\n#  * 空白格用 '.' 表示。# 示例 1：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png]\n# 输入：board = # [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n# ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n# ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n# ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n# ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n# ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n# ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n# ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n# ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n# 输出：true# 示例 2：# 输入：board = # [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n# ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n# ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n# ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n# ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n# ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n# ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n# ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n# ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n# 输出：false# 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n# 提示：#  * board.length == 9#  * board[i].length == 9#  * board[i][j] 是一位数字（1-9）或者 '.'\n"
    },
    {
        "name": "spiral_matrix",
        "url": "https://leetcode.cn/problems/spiral-matrix/description",
        "title": "54. 螺旋矩阵 - 力扣（LeetCode）",
        "content": "# 54. 螺旋矩阵 - 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg]\n# 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n# 输出：[1,2,3,6,9,8,7,4,5]# 示例 2：# [https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg]\n# 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n# 输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n# 提示：#  * m == matrix.length#  * n == matrix[i].length\n#  * 1 <= m, n <= 10#  * -100 <= matrix[i][j] <= 100\n"
    },
    {
        "name": "rotate_image",
        "url": "https://leetcode.cn/problems/rotate-image/description",
        "title": "48. 旋转图像 - 力扣（LeetCode）",
        "content": "# 48. 旋转图像 - 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n# 你必须在 原地 [https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95] 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg]\n# 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n# 输出：[[7,4,1],[8,5,2],[9,6,3]]\n# 示例 2：# [https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg]\n# 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n# 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n# 提示：#  * n == matrix.length == matrix[i].length\n#  * 1 <= n <= 20#  * -1000 <= matrix[i][j] <= 1000\n"
    },
    {
        "name": "set_matrix_zeroes",
        "url": "https://leetcode.cn/problems/set-matrix-zeroes/description",
        "title": "73. 矩阵置零 - 力扣（LeetCode）",
        "content": "# 73. 矩阵置零 - 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 [http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95] 算法。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg]\n# 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\n# 输出：[[1,0,1],[0,0,0],[1,0,1]]\n# 示例 2：# [https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg]\n# 输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n# 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n# 提示：#  * m == matrix.length#  * n == matrix[0].length\n#  * 1 <= m, n <= 200#  * -231 <= matrix[i][j] <= 231 - 1\n# 进阶：#  * 一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n#  * 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。\n#  * 你能想出一个仅使用常量空间的解决方案吗？"
    },
    {
        "name": "game_of_life",
        "url": "https://leetcode.cn/problems/game-of-life/description",
        "title": "289. 生命游戏 - 力扣（LeetCode）",
        "content": "# 289. 生命游戏 - 根据 百度百科 [https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin] ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\n# 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n#  1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；\n#  2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；\n#  3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；\n#  4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；\n# 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg]\n# 输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n# 输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n# 示例 2：# [https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg]\n# 输入：board = [[1,1],[1,0]]\n# 输出：[[1,1],[1,1]]# 提示：#  * m == board.length#  * n == board[i].length#  * 1 <= m, n <= 25#  * board[i][j] 为 0 或 1# 进阶：#  * 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。\n#  * 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？\n"
    },
    {
        "name": "ransom_note",
        "url": "https://leetcode.cn/problems/ransom-note/description",
        "title": "383. 赎金信 - 力扣（LeetCode）",
        "content": "# 383. 赎金信 - 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\n# 如果可以，返回 true ；否则返回 false 。\n# magazine 中的每个字符只能在 ransomNote 中使用一次。\n# 示例 1：# 输入：ransomNote = \"a\", magazine = \"b\"\n# 输出：false# 示例 2：# 输入：ransomNote = \"aa\", magazine = \"ab\"\n# 输出：false# 示例 3：# 输入：ransomNote = \"aa\", magazine = \"aab\"\n# 输出：true# 提示：#  * 1 <= ransomNote.length, magazine.length <= 105\n#  * ransomNote 和 magazine 由小写英文字母组成\n"
    },
    {
        "name": "isomorphic_strings",
        "url": "https://leetcode.cn/problems/isomorphic-strings/description",
        "title": "205. 同构字符串 - 力扣（LeetCode）",
        "content": "# 205. 同构字符串 - 给定两个字符串 s 和 t ，判断它们是否是同构的。\n# 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n# 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n# 示例 1:# 输入：s = \"egg\", t = \"add\"# 输出：true# 示例 2：# 输入：s = \"foo\", t = \"bar\"# 输出：false# 示例 3：# 输入：s = \"paper\", t = \"title\"\n# 输出：true# 提示：#  * 1 <= s.length <= 5 * 104\n#  * t.length == s.length#  * s 和 t 由任意有效的 ASCII 字符组成\n"
    },
    {
        "name": "word_pattern",
        "url": "https://leetcode.cn/problems/word-pattern/description",
        "title": "290. 单词规律 - 力扣（LeetCode）",
        "content": "# 290. 单词规律 - 给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。\n# 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。\n# 示例1:# 输入: pattern = \"abba\", s = \"dog cat cat dog\"\n# 输出: true# 示例 2:# 输入:pattern = \"abba\", s = \"dog cat cat fish\"\n# 输出: false# 示例 3:# 输入: pattern = \"aaaa\", s = \"dog cat cat dog\"\n# 输出: false# 提示:#  * 1 <= pattern.length <= 300\n#  * pattern 只包含小写英文字母#  * 1 <= s.length <= 3000\n#  * s 只包含小写英文字母和 ' '#  * s 不包含 任何前导或尾随对空格#  * s 中每个单词都被 单个空格 分隔"
    },
    {
        "name": "valid_anagram",
        "url": "https://leetcode.cn/problems/valid-anagram/description",
        "title": "242. 有效的字母异位词 - 力扣（LeetCode）",
        "content": "# 242. 有效的字母异位词 - 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n# 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\n# 示例 1:# 输入: s = \"anagram\", t = \"nagaram\"\n# 输出: true# 示例 2:# 输入: s = \"rat\", t = \"car\"\n# 输出: false# 提示:#  * 1 <= s.length, t.length <= 5 * 104\n#  * s 和 t 仅包含小写字母# 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n"
    },
    {
        "name": "group_anagrams",
        "url": "https://leetcode.cn/problems/group-anagrams/description",
        "title": "49. 字母异位词分组 - 力扣（LeetCode）",
        "content": "# 49. 字母异位词分组 - 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n# 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n# 示例 1:# 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n# 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n# 示例 2:# 输入: strs = [\"\"]# 输出: [[\"\"]]# 示例 3:# 输入: strs = [\"a\"]# 输出: [[\"a\"]]# 提示：#  * 1 <= strs.length <= 104\n#  * 0 <= strs[i].length <= 100\n#  * strs[i] 仅包含小写字母"
    },
    {
        "name": "two_sum",
        "url": "https://leetcode.cn/problems/two-sum/description",
        "title": "1. 两数之和 - 力扣（LeetCode）",
        "content": "# 1. 两数之和 - 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n# 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n# 你可以按任意顺序返回答案。# 示例 1：# 输入：nums = [2,7,11,15], target = 9\n# 输出：[0,1]# 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n# 示例 2：# 输入：nums = [3,2,4], target = 6\n# 输出：[1,2]# 示例 3：# 输入：nums = [3,3], target = 6\n# 输出：[0,1]# 提示：#  * 2 <= nums.length <= 104\n#  * -109 <= nums[i] <= 109\n#  * -109 <= target <= 109\n#  * 只会存在一个有效答案# 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n"
    },
    {
        "name": "happy_number",
        "url": "https://leetcode.cn/problems/happy-number/description",
        "title": "202. 快乐数 - 力扣（LeetCode）",
        "content": "# 202. 快乐数 - 编写一个算法来判断一个数 n 是不是快乐数。\n# 「快乐数」 定义为：#  * 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n#  * 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n#  * 如果这个过程 结果为 1，那么这个数就是快乐数。\n# 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\n# 示例 1：# 输入：n = 19# 输出：true# 解释：# 12 + 92 = 82# 82 + 22 = 68# 62 + 82 = 100# 12 + 02 + 02 = 1# 示例 2：# 输入：n = 2# 输出：false# 提示：#  * 1 <= n <= 231 - 1"
    },
    {
        "name": "contains_duplicate_ii",
        "url": "https://leetcode.cn/problems/contains-duplicate-ii/description",
        "title": "219. 存在重复元素 II - 力扣（LeetCode）",
        "content": "# 219. 存在重复元素 II - 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。\n# 示例 1：# 输入：nums = [1,2,3,1], k = 3\n# 输出：true# 示例 2：# 输入：nums = [1,0,1,1], k = 1\n# 输出：true# 示例 3：# 输入：nums = [1,2,3,1,2,3], k = 2\n# 输出：false# 提示：#  * 1 <= nums.length <= 105\n#  * -109 <= nums[i] <= 109\n#  * 0 <= k <= 105"
    },
    {
        "name": "longest_consecutive_sequence",
        "url": "https://leetcode.cn/problems/longest-consecutive-sequence/description",
        "title": "128. 最长连续序列 - 力扣（LeetCode）",
        "content": "# 128. 最长连续序列 - 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n# 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\n# 示例 1：# 输入：nums = [100,4,200,1,3,2]\n# 输出：4# 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n# 示例 2：# 输入：nums = [0,3,7,2,5,8,4,6,0,1]\n# 输出：9# 提示：#  * 0 <= nums.length <= 105\n#  * -109 <= nums[i] <= 109\n"
    },
    {
        "name": "summary_ranges",
        "url": "https://leetcode.cn/problems/summary-ranges/description",
        "title": "228. 汇总区间 - 力扣（LeetCode）",
        "content": "# 228. 汇总区间 - 给定一个  无重复元素 的 有序 整数数组 nums 。\n# 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。\n# 列表中的每个区间范围 [a,b] 应该按如下格式输出：\n#  * \"a->b\" ，如果 a != b#  * \"a\" ，如果 a == b# 示例 1：# 输入：nums = [0,1,2,4,5,7]# 输出：[\"0->2\",\"4->5\",\"7\"]# 解释：区间范围是：# [0,2] --> \"0->2\"# [4,5] --> \"4->5\"# [7,7] --> \"7\"# 示例 2：# 输入：nums = [0,2,3,4,6,8,9]\n# 输出：[\"0\",\"2->4\",\"6\",\"8->9\"]\n# 解释：区间范围是：# [0,0] --> \"0\"# [2,4] --> \"2->4\"# [6,6] --> \"6\"# [8,9] --> \"8->9\"# 提示：#  * 0 <= nums.length <= 20\n#  * -231 <= nums[i] <= 231 - 1\n#  * nums 中的所有值都 互不相同#  * nums 按升序排列"
    },
    {
        "name": "merge_intervals",
        "url": "https://leetcode.cn/problems/merge-intervals/description",
        "title": "56. 合并区间 - 力扣（LeetCode）",
        "content": "# 56. 合并区间 - 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n# 示例 1：# 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n# 输出：[[1,6],[8,10],[15,18]]\n# 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n# 示例 2：# 输入：intervals = [[1,4],[4,5]]\n# 输出：[[1,5]]# 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n# 提示：#  * 1 <= intervals.length <= 104\n#  * intervals[i].length == 2\n#  * 0 <= starti <= endi <= 104\n"
    },
    {
        "name": "insert_interval",
        "url": "https://leetcode.cn/problems/insert-interval/description",
        "title": "57. 插入区间 - 力扣（LeetCode）",
        "content": "# 57. 插入区间 - 给你一个 无重叠的 ，按照区间起始端点排序的区间列表 intervals，其中 intervals[i] = [starti, endi] 表示第 i 个区间的开始和结束，并且 intervals 按照 starti 升序排列。同样给定一个区间 newInterval = [start, end] 表示另一个区间的开始和结束。\n# 在 intervals 中插入区间 newInterval，使得 intervals 依然按照 starti 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。\n# 返回插入之后的 intervals。# 注意 你不需要原地修改 intervals。你可以创建一个新数组然后返回它。\n# 示例 1：# 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]\n# 输出：[[1,5],[6,9]]# 示例 2：# 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n# 输出：[[1,2],[3,10],[12,16]]\n# 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。\n# 提示：#  * 0 <= intervals.length <= 104\n#  * intervals[i].length == 2\n#  * 0 <= starti <= endi <= 105\n#  * intervals 根据 starti 按 升序 排列\n#  * newInterval.length == 2\n#  * 0 <= start <= end <= 105\n"
    },
    {
        "name": "minimum_number_of_arrows_to_burst_balloons",
        "url": "https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description",
        "title": "452. 用最少数量的箭引爆气球 - 力扣（LeetCode）",
        "content": "# 452. 用最少数量的箭引爆气球 - 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。\n# 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。\n# 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\n# 示例 1：# 输入：points = [[10,16],[2,8],[1,6],[7,12]]\n# 输出：2# 解释：气球可以用2支箭来爆破:# -在x = 6处射出箭，击破气球[2,8]和[1,6]。\n# -在x = 11处发射箭，击破气球[10,16]和[7,12]。\n# 示例 2：# 输入：points = [[1,2],[3,4],[5,6],[7,8]]\n# 输出：4# 解释：每个气球需要射出一支箭，总共需要4支箭。# 示例 3：# 输入：points = [[1,2],[2,3],[3,4],[4,5]]\n# 输出：2# 解释：气球可以用2支箭来爆破:# - 在x = 2处发射箭，击破气球[1,2]和[2,3]。\n# - 在x = 4处射出箭，击破气球[3,4]和[4,5]。\n# 提示:#  * 1 <= points.length <= 105\n#  * points[i].length == 2\n#  * -231 <= xstart < xend <= 231 - 1\n"
    },
    {
        "name": "valid_parentheses",
        "url": "https://leetcode.cn/problems/valid-parentheses/description",
        "title": "20. 有效的括号 - 力扣（LeetCode）",
        "content": "# 20. 有效的括号 - 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n# 有效字符串需满足：#  1. 左括号必须用相同类型的右括号闭合。#  2. 左括号必须以正确的顺序闭合。#  3. 每个右括号都有一个对应的相同类型的左括号。\n# 示例 1：# 输入：s = \"()\"# 输出：true# 示例 2：# 输入：s = \"()[]{}\"# 输出：true# 示例 3：# 输入：s = \"(]\"# 输出：false# 提示：#  * 1 <= s.length <= 104#  * s 仅由括号 '()[]{}' 组成"
    },
    {
        "name": "simplify_path",
        "url": "https://leetcode.cn/problems/simplify-path/description",
        "title": "71. 简化路径 - 力扣（LeetCode）",
        "content": "# 71. 简化路径 - 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。\n# 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。\n# 请注意，返回的 规范路径 必须遵循下述格式：#  * 始终以斜杠 '/' 开头。#  * 两个目录名之间必须只有一个斜杠 '/' 。\n#  * 最后一个目录名（如果存在）不能 以 '/' 结尾。\n#  * 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。\n# 返回简化后得到的 规范路径 。# 示例 1：# 输入：path = \"/home/\"# 输出：\"/home\"# 解释：注意，最后一个目录名后面没有斜杠。 # 示例 2：# 输入：path = \"/../\"# 输出：\"/\"# 解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n# 示例 3：# 输入：path = \"/home//foo/\"# 输出：\"/home/foo\"# 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n# 示例 4：# 输入：path = \"/a/./b/../../c/\"\n# 输出：\"/c\"# 提示：#  * 1 <= path.length <= 3000\n#  * path 由英文字母，数字，'.'，'/' 或 '_' 组成。\n#  * path 是一个有效的 Unix 风格绝对路径。\n"
    },
    {
        "name": "min_stack",
        "url": "https://leetcode.cn/problems/min-stack/description",
        "title": "155. 最小栈 - 力扣（LeetCode）",
        "content": "# 155. 最小栈 - 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n# 实现 MinStack 类:#  * MinStack() 初始化堆栈对象。#  * void push(int val) 将元素val推入堆栈。\n#  * void pop() 删除堆栈顶部的元素。\n#  * int top() 获取堆栈顶部的元素。#  * int getMin() 获取堆栈中的最小元素。\n# 示例 1:# 输入：# [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n# [[],[-2],[0],[-3],[],[],[],[]]\n# 输出：# [null,null,null,null,-3,null,0,-2]\n# 解释：# MinStack minStack = new MinStack();\n# minStack.push(-2);# minStack.push(0);# minStack.push(-3);# minStack.getMin();   --> 返回 -3.\n# minStack.pop();# minStack.top();      --> 返回 0.\n# minStack.getMin();   --> 返回 -2.\n# 提示：#  * -231 <= val <= 231 - 1\n#  * pop、top 和 getMin 操作总是在 非空栈 上调用\n#  * push, pop, top, and getMin最多被调用 3 * 104 次\n"
    },
    {
        "name": "evaluate_reverse_polish_notation",
        "url": "https://leetcode.cn/problems/evaluate-reverse-polish-notation/description",
        "title": "150. 逆波兰表达式求值 - 力扣（LeetCode）",
        "content": "# 150. 逆波兰表达式求值 - 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 [https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437] 表示的算术表达式。\n# 请你计算该表达式。返回一个表示表达式值的整数。# 注意：#  * 有效的算符为 '+'、'-'、'*' 和 '/' 。\n#  * 每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n#  * 两个整数之间的除法总是 向零截断 。#  * 表达式中不含除零运算。#  * 输入是一个根据逆波兰表示法表示的算术表达式。\n#  * 答案及所有中间计算结果可以用 32 位 整数表示。\n# 示例 1：# 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n# 输出：9# 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n# 示例 2：# 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n# 输出：6# 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n# 示例 3：# 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n# 输出：22# 解释：该算式转化为常见的中缀算术表达式为：#   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n# = ((10 * (6 / (12 * -11))) + 17) + 5\n# = ((10 * (6 / -132)) + 17) + 5\n# = ((10 * 0) + 17) + 5# = (0 + 17) + 5# = 17 + 5# = 22# 提示：#  * 1 <= tokens.length <= 104\n#  * tokens[i] 是一个算符（\"+\"、\"-\"、\"*\" 或 \"/\"），或是在范围 [-200, 200] 内的一个整数\n# 逆波兰表达式：# 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n#  * 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。\n#  * 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。\n# 逆波兰表达式主要有以下两个优点：#  * 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。\n#  * 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中\n"
    },
    {
        "name": "basic_calculator",
        "url": "https://leetcode.cn/problems/basic-calculator/description",
        "title": "224. 基本计算器 - 力扣（LeetCode）",
        "content": "# 224. 基本计算器 - 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n# 注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。\n# 示例 1：# 输入：s = \"1 + 1\"# 输出：2# 示例 2：# 输入：s = \" 2-1 + 2 \"# 输出：3# 示例 3：# 输入：s = \"(1+(4+5+2)-3)+(6+8)\"\n# 输出：23# 提示：#  * 1 <= s.length <= 3 * 105\n#  * s 由数字、'+'、'-'、'('、')'、和 ' ' 组成\n#  * s 表示一个有效的表达式#  * '+' 不能用作一元运算(例如， \"+1\" 和 \"+(2 + 3)\" 无效)\n#  * '-' 可以用作一元运算(即 \"-1\" 和 \"-(2 + 3)\" 是有效的)\n#  * 输入中不存在两个连续的操作符#  * 每个数字和运行的计算将适合于一个有符号的 32位 整数\n"
    },
    {
        "name": "linked_list_cycle",
        "url": "https://leetcode.cn/problems/linked-list-cycle/description",
        "title": "141. 环形链表 - 力扣（LeetCode）",
        "content": "# 141. 环形链表 - 给你一个链表的头节点 head ，判断链表中是否有环。\n# 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n# 如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n# 示例 1：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png]\n# 输入：head = [3,2,0,-4], pos = 1\n# 输出：true# 解释：链表中有一个环，其尾部连接到第二个节点。# 示例 2：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png]\n# 输入：head = [1,2], pos = 0\n# 输出：true# 解释：链表中有一个环，其尾部连接到第一个节点。# 示例 3：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png]\n# 输入：head = [1], pos = -1# 输出：false# 解释：链表中没有环。# 提示：#  * 链表中节点的数目范围是 [0, 104]#  * -105 <= Node.val <= 105\n#  * pos 为 -1 或者链表中的一个 有效索引 。\n# 进阶：你能用 O(1)（即，常量）内存解决此问题吗？\n"
    },
    {
        "name": "add_two_numbers",
        "url": "https://leetcode.cn/problems/add-two-numbers/description",
        "title": "2. 两数相加 - 力扣（LeetCode）",
        "content": "# 2. 两数相加 - 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n# 请你将两个数相加，并以相同形式返回一个表示和的链表。\n# 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n# 示例 1：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg]\n# 输入：l1 = [2,4,3], l2 = [5,6,4]\n# 输出：[7,0,8]# 解释：342 + 465 = 807.# 示例 2：# 输入：l1 = [0], l2 = [0]# 输出：[0]# 示例 3：# 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# 输出：[8,9,9,9,0,0,0,1]# 提示：#  * 每个链表中的节点数在范围 [1, 100] 内\n#  * 0 <= Node.val <= 9#  * 题目数据保证列表表示的数字不含前导零"
    },
    {
        "name": "merge_two_sorted_lists",
        "url": "https://leetcode.cn/problems/merge-two-sorted-lists/description",
        "title": "21. 合并两个有序链表 - 力扣（LeetCode）",
        "content": "# 21. 合并两个有序链表 - 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n# 示例 1：# [https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg]\n# 输入：l1 = [1,2,4], l2 = [1,3,4]\n# 输出：[1,1,2,3,4,4]# 示例 2：# 输入：l1 = [], l2 = []# 输出：[]# 示例 3：# 输入：l1 = [], l2 = [0]# 输出：[0]# 提示：#  * 两个链表的节点数目范围是 [0, 50]#  * -100 <= Node.val <= 100\n#  * l1 和 l2 均按 非递减顺序 排列"
    },
    {
        "name": "copy_list_with_random_pointer",
        "url": "https://leetcode.cn/problems/copy-list-with-random-pointer/description",
        "title": "138. 随机链表的复制 - 力扣（LeetCode）",
        "content": "# 138. 随机链表的复制 - 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n# 构造这个链表的 深拷贝 [https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin]。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n# 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。\n# 返回复制链表的头节点。# 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\n#  * val：一个表示 Node.val 的整数。\n#  * random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。\n# 你的代码 只 接受原链表的头节点 head 作为传入参数。\n# 示例 1：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png]\n# 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n# 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n# 示例 2：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png]\n# 输入：head = [[1,1],[2,1]]# 输出：[[1,1],[2,1]]# 示例 3：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png]\n# 输入：head = [[3,null],[3,0],[3,null]]\n# 输出：[[3,null],[3,0],[3,null]]\n# 提示：#  * 0 <= n <= 1000#  * -104 <= Node.val <= 104\n#  * Node.random 为 null 或指向链表中的节点。\n"
    },
    {
        "name": "reverse_linked_list_ii",
        "url": "https://leetcode.cn/problems/reverse-linked-list-ii/description",
        "title": "92. 反转链表 II - 力扣（LeetCode）",
        "content": "# 92. 反转链表 II - 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg]\n# 输入：head = [1,2,3,4,5], left = 2, right = 4\n# 输出：[1,4,3,2,5]# 示例 2：# 输入：head = [5], left = 1, right = 1\n# 输出：[5]# 提示：#  * 链表中节点数目为 n#  * 1 <= n <= 500#  * -500 <= Node.val <= 500\n#  * 1 <= left <= right <= n\n# 进阶： 你可以使用一趟扫描完成反转吗？"
    },
    {
        "name": "reverse_nodes_in_k_group",
        "url": "https://leetcode.cn/problems/reverse-nodes-in-k-group/description",
        "title": "25. K 个一组翻转链表 - 力扣（LeetCode）",
        "content": "# 25. K 个一组翻转链表 - 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\n# k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n# 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg]\n# 输入：head = [1,2,3,4,5], k = 2\n# 输出：[2,1,4,3,5]# 示例 2：# [https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg]\n# 输入：head = [1,2,3,4,5], k = 3\n# 输出：[3,2,1,4,5]# 提示：#  * 链表中的节点数目为 n#  * 1 <= k <= n <= 5000#  * 0 <= Node.val <= 1000\n# 进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？\n"
    },
    {
        "name": "remove_nth_node_from_end_of_list",
        "url": "https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description",
        "title": "19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）",
        "content": "# 19. 删除链表的倒数第 N 个结点 - 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg]\n# 输入：head = [1,2,3,4,5], n = 2\n# 输出：[1,2,3,5]# 示例 2：# 输入：head = [1], n = 1# 输出：[]# 示例 3：# 输入：head = [1,2], n = 1# 输出：[1]# 提示：#  * 链表中结点的数目为 sz#  * 1 <= sz <= 30#  * 0 <= Node.val <= 100#  * 1 <= n <= sz# 进阶：你能尝试使用一趟扫描实现吗？"
    },
    {
        "name": "remove_duplicates_from_sorted_list_ii",
        "url": "https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description",
        "title": "82. 删除排序链表中的重复元素 II - 力扣（LeetCode）",
        "content": "# 82. 删除排序链表中的重复元素 II - 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg]\n# 输入：head = [1,2,3,3,4,4,5]\n# 输出：[1,2,5]# 示例 2：# [https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg]\n# 输入：head = [1,1,1,2,3]# 输出：[2,3]# 提示：#  * 链表中节点数目在范围 [0, 300] 内\n#  * -100 <= Node.val <= 100\n#  * 题目数据保证链表已经按升序 排列"
    },
    {
        "name": "rotate_list",
        "url": "https://leetcode.cn/problems/rotate-list/description",
        "title": "61. 旋转链表 - 力扣（LeetCode）",
        "content": "# 61. 旋转链表 - 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg]\n# 输入：head = [1,2,3,4,5], k = 2\n# 输出：[4,5,1,2,3]# 示例 2：# [https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg]\n# 输入：head = [0,1,2], k = 4\n# 输出：[2,0,1]# 提示：#  * 链表中节点的数目在范围 [0, 500] 内\n#  * -100 <= Node.val <= 100\n#  * 0 <= k <= 2 * 109"
    },
    {
        "name": "partition_list",
        "url": "https://leetcode.cn/problems/partition-list/description",
        "title": "86. 分隔链表 - 力扣（LeetCode）",
        "content": "# 86. 分隔链表 - 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。\n# 你应当 保留 两个分区中每个节点的初始相对位置。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/01/04/partition.jpg]\n# 输入：head = [1,4,3,2,5,2], x = 3\n# 输出：[1,2,2,4,3,5]# 示例 2：# 输入：head = [2,1], x = 2# 输出：[1,2]# 提示：#  * 链表中节点的数目在范围 [0, 200] 内\n#  * -100 <= Node.val <= 100\n#  * -200 <= x <= 200"
    },
    {
        "name": "lru_cache",
        "url": "https://leetcode.cn/problems/lru-cache/description",
        "title": "146. LRU 缓存 - 力扣（LeetCode）",
        "content": "# 146. LRU 缓存 - 请你设计并实现一个满足  LRU (最近最少使用) 缓存 [https://baike.baidu.com/item/LRU] 约束的数据结构。\n# 实现 LRUCache 类：#  * LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\n#  * int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n#  * void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n# 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n# 示例：# 输入# [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n# [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n# 输出# [null, null, null, 1, null, -1, null, -1, 3, 4]\n# 解释# LRUCache lRUCache = new LRUCache(2);\n# lRUCache.put(1, 1); // 缓存是 {1=1}\n# lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\n# lRUCache.get(1);    // 返回 1\n# lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\n# lRUCache.get(2);    // 返回 -1 (未找到)\n# lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\n# lRUCache.get(1);    // 返回 -1 (未找到)\n# lRUCache.get(3);    // 返回 3\n# lRUCache.get(4);    // 返回 4\n# 提示：#  * 1 <= capacity <= 3000\n#  * 0 <= key <= 10000#  * 0 <= value <= 105#  * 最多调用 2 * 105 次 get 和 put\n"
    },
    {
        "name": "maximum_depth_of_binary_tree",
        "url": "https://leetcode.cn/problems/maximum-depth-of-binary-tree/description",
        "title": "104. 二叉树的最大深度 - 力扣（LeetCode）",
        "content": "# 104. 二叉树的最大深度 - 给定一个二叉树 root ，返回其最大深度。\n# 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg]\n# 输入：root = [3,9,20,null,null,15,7]\n# 输出：3# 示例 2：# 输入：root = [1,null,2]# 输出：2# 提示：#  * 树中节点的数量在 [0, 104] 区间内。\n#  * -100 <= Node.val <= 100\n"
    },
    {
        "name": "same_tree",
        "url": "https://leetcode.cn/problems/same-tree/description",
        "title": "100. 相同的树 - 力扣（LeetCode）",
        "content": "# 100. 相同的树 - 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n# 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg]\n# 输入：p = [1,2,3], q = [1,2,3]\n# 输出：true# 示例 2：# [https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg]\n# 输入：p = [1,2], q = [1,null,2]\n# 输出：false# 示例 3：# [https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg]\n# 输入：p = [1,2,1], q = [1,1,2]\n# 输出：false# 提示：#  * 两棵树上的节点数目都在范围 [0, 100] 内\n#  * -104 <= Node.val <= 104\n"
    },
    {
        "name": "invert_binary_tree",
        "url": "https://leetcode.cn/problems/invert-binary-tree/description",
        "title": "226. 翻转二叉树 - 力扣（LeetCode）",
        "content": "# 226. 翻转二叉树 - 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg]\n# 输入：root = [4,2,7,1,3,6,9]\n# 输出：[4,7,2,9,6,3,1]# 示例 2：# [https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg]\n# 输入：root = [2,1,3]# 输出：[2,3,1]# 示例 3：# 输入：root = []# 输出：[]# 提示：#  * 树中节点数目范围在 [0, 100] 内#  * -100 <= Node.val <= 100\n"
    },
    {
        "name": "symmetric_tree",
        "url": "https://leetcode.cn/problems/symmetric-tree/description",
        "title": "101. 对称二叉树 - 力扣（LeetCode）",
        "content": "# 101. 对称二叉树 - 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n# 示例 1：# [https://pic.leetcode.cn/1698026966-JDYPDU-image.png]\n# 输入：root = [1,2,2,3,4,4,3]\n# 输出：true# 示例 2：# [https://pic.leetcode.cn/1698027008-nPFLbM-image.png]\n# 输入：root = [1,2,2,null,3,null,3]\n# 输出：false# 提示：#  * 树中节点数目在范围 [1, 1000] 内\n#  * -100 <= Node.val <= 100\n# 进阶：你可以运用递归和迭代两种方法解决这个问题吗？\n"
    },
    {
        "name": "construct_binary_tree_from_preorder_and_inorder_traversal",
        "url": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description",
        "title": "105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）",
        "content": "# 105. 从前序与中序遍历序列构造二叉树 - 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\n# 示例 1:# [https://assets.leetcode.com/uploads/2021/02/19/tree.jpg]\n# 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n# 输出: [3,9,20,null,null,15,7]\n# 示例 2:# 输入: preorder = [-1], inorder = [-1]\n# 输出: [-1]# 提示:#  * 1 <= preorder.length <= 3000\n#  * inorder.length == preorder.length\n#  * -3000 <= preorder[i], inorder[i] <= 3000\n#  * preorder 和 inorder 均 无重复 元素\n#  * inorder 均出现在 preorder\n#  * preorder 保证 为二叉树的前序遍历序列\n#  * inorder 保证 为二叉树的中序遍历序列\n"
    },
    {
        "name": "construct_binary_tree_from_inorder_and_postorder_traversal",
        "url": "https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description",
        "title": "106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）",
        "content": "# 106. 从中序与后序遍历序列构造二叉树 - 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n# 示例 1:# [https://assets.leetcode.com/uploads/2021/02/19/tree.jpg]\n# 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n# 输出：[3,9,20,null,null,15,7]\n# 示例 2:# 输入：inorder = [-1], postorder = [-1]\n# 输出：[-1]# 提示:#  * 1 <= inorder.length <= 3000\n#  * postorder.length == inorder.length\n#  * -3000 <= inorder[i], postorder[i] <= 3000\n#  * inorder 和 postorder 都由 不同 的值组成\n#  * postorder 中每一个值都在 inorder 中\n#  * inorder 保证是树的中序遍历#  * postorder 保证是树的后序遍历"
    },
    {
        "name": "populating_next_right_pointers_in_each_node_ii",
        "url": "https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description",
        "title": "117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）",
        "content": "# 117. 填充每个节点的下一个右侧节点指针 II - 给定一个二叉树：\n# struct Node {#   int val;#   Node *left;#   Node *right;#   Node *next;# }# 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。\n# 初始状态下，所有 next 指针都被设置为 NULL 。\n# 示例 1：# [https://assets.leetcode.com/uploads/2019/02/15/117_sample.png]\n# 输入：root = [1,2,3,4,5,null,7]\n# 输出：[1,#,2,3,#,4,5,7,#]# 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。\n# 示例 2：# 输入：root = []# 输出：[]# 提示：#  * 树中的节点数在范围 [0, 6000] 内\n#  * -100 <= Node.val <= 100\n# 进阶：#  * 你只能使用常量级额外空间。#  * 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。\n"
    },
    {
        "name": "flatten_binary_tree_to_linked_list",
        "url": "https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description",
        "title": "114. 二叉树展开为链表 - 力扣（LeetCode）",
        "content": "# 114. 二叉树展开为链表 - 给你二叉树的根结点 root ，请你将它展开为一个单链表：\n#  * 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。\n#  * 展开后的单链表应该与二叉树 先序遍历 [https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin] 顺序相同。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg]\n# 输入：root = [1,2,5,3,4,null,6]\n# 输出：[1,null,2,null,3,null,4,null,5,null,6]\n# 示例 2：# 输入：root = []# 输出：[]# 示例 3：# 输入：root = [0]# 输出：[0]# 提示：#  * 树中结点数在范围 [0, 2000] 内#  * -100 <= Node.val <= 100\n# 进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？\n"
    },
    {
        "name": "path_sum",
        "url": "https://leetcode.cn/problems/path-sum/description",
        "title": "112. 路径总和 - 力扣（LeetCode）",
        "content": "# 112. 路径总和 - 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n# 叶子节点 是指没有子节点的节点。# 示例 1：# [https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg]\n# 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n# 输出：true# 解释：等于目标和的根节点到叶节点路径如上图所示。\n# 示例 2：# [https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg]\n# 输入：root = [1,2,3], targetSum = 5\n# 输出：false# 解释：树中存在两条根节点到叶子节点的路径：# (1 --> 2): 和为 3# (1 --> 3): 和为 4# 不存在 sum = 5 的根节点到叶子节点的路径。\n# 示例 3：# 输入：root = [], targetSum = 0\n# 输出：false# 解释：由于树是空的，所以不存在根节点到叶子节点的路径。\n# 提示：#  * 树中节点的数目在范围 [0, 5000] 内\n#  * -1000 <= Node.val <= 1000\n#  * -1000 <= targetSum <= 1000\n"
    },
    {
        "name": "sum_root_to_leaf_numbers",
        "url": "https://leetcode.cn/problems/sum-root-to-leaf-numbers/description",
        "title": "129. 求根节点到叶节点数字之和 - 力扣（LeetCode）",
        "content": "# 129. 求根节点到叶节点数字之和 - 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n# 每条从根节点到叶节点的路径都代表一个数字：#  * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n# 计算从根节点到叶节点生成的 所有数字之和 。# 叶节点 是指没有子节点的节点。# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg]\n# 输入：root = [1,2,3]# 输出：25# 解释：# 从根到叶子节点路径 1->2 代表数字 12# 从根到叶子节点路径 1->3 代表数字 13# 因此，数字总和 = 12 + 13 = 25# 示例 2：# [https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg]\n# 输入：root = [4,9,0,5,1]# 输出：1026# 解释：# 从根到叶子节点路径 4->9->5 代表数字 495\n# 从根到叶子节点路径 4->9->1 代表数字 491\n# 从根到叶子节点路径 4->0 代表数字 40# 因此，数字总和 = 495 + 491 + 40 = 1026\n# 提示：#  * 树中节点的数目在范围 [1, 1000] 内\n#  * 0 <= Node.val <= 9#  * 树的深度不超过 10"
    },
    {
        "name": "binary_tree_maximum_path_sum",
        "url": "https://leetcode.cn/problems/binary-tree-maximum-path-sum/description",
        "title": "124. 二叉树中的最大路径和 - 力扣（LeetCode）",
        "content": "# 124. 二叉树中的最大路径和 - 二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n# 路径和 是路径中各节点值的总和。# 给你一个二叉树的根节点 root ，返回其 最大路径和 。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg]\n# 输入：root = [1,2,3]# 输出：6# 解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n# 示例 2：# [https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg]\n# 输入：root = [-10,9,20,null,null,15,7]\n# 输出：42# 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n# 提示：#  * 树中节点数目范围是 [1, 3 * 104]\n#  * -1000 <= Node.val <= 1000\n"
    },
    {
        "name": "binary_search_tree_iterator",
        "url": "https://leetcode.cn/problems/binary-search-tree-iterator/description",
        "title": "173. 二叉搜索树迭代器 - 力扣（LeetCode）",
        "content": "# 173. 二叉搜索树迭代器 - 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\n#  * BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。\n#  * boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。\n#  * int next()将指针向右移动，然后返回指针处的数字。\n# 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。\n# 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。\n# 示例：# [https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png]\n# 输入# [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n# [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n# 输出# [null, 3, 7, true, 9, true, 15, true, 20, false]\n# 解释# BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\n# bSTIterator.next();    // 返回 3\n# bSTIterator.next();    // 返回 7\n# bSTIterator.hasNext(); // 返回 True\n# bSTIterator.next();    // 返回 9\n# bSTIterator.hasNext(); // 返回 True\n# bSTIterator.next();    // 返回 15\n# bSTIterator.hasNext(); // 返回 True\n# bSTIterator.next();    // 返回 20\n# bSTIterator.hasNext(); // 返回 False\n# 提示：#  * 树中节点的数目在范围 [1, 105] 内\n#  * 0 <= Node.val <= 106#  * 最多调用 105 次 hasNext 和 next 操作\n# 进阶：#  * 你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。\n"
    },
    {
        "name": "count_complete_tree_nodes",
        "url": "https://leetcode.cn/problems/count-complete-tree-nodes/description",
        "title": "222. 完全二叉树的节点个数 - 力扣（LeetCode）",
        "content": "# 222. 完全二叉树的节点个数 - 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n# 完全二叉树 [https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin] 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/01/14/complete.jpg]\n# 输入：root = [1,2,3,4,5,6]# 输出：6# 示例 2：# 输入：root = []# 输出：0# 示例 3：# 输入：root = [1]# 输出：1# 提示：#  * 树中节点的数目范围是[0, 5 * 104]\n#  * 0 <= Node.val <= 5 * 104\n#  * 题目数据保证输入的树是 完全二叉树# 进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？\n"
    },
    {
        "name": "lowest_common_ancestor_of_a_binary_tree",
        "url": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description",
        "title": "236. 二叉树的最近公共祖先 - 力扣（LeetCode）",
        "content": "# 236. 二叉树的最近公共祖先 - 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n# 百度百科 [https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin]中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n# 示例 1：# [https://assets.leetcode.com/uploads/2018/12/14/binarytree.png]\n# 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n# 输出：3# 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n# 示例 2：# [https://assets.leetcode.com/uploads/2018/12/14/binarytree.png]\n# 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n# 输出：5# 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n# 示例 3：# 输入：root = [1,2], p = 1, q = 2\n# 输出：1# 提示：#  * 树中节点数目在范围 [2, 105] 内。\n#  * -109 <= Node.val <= 109\n#  * 所有 Node.val 互不相同 。#  * p != q#  * p 和 q 均存在于给定的二叉树中。"
    },
    {
        "name": "binary_tree_right_side_view",
        "url": "https://leetcode.cn/problems/binary-tree-right-side-view/description",
        "title": "199. 二叉树的右视图 - 力扣（LeetCode）",
        "content": "# 199. 二叉树的右视图 - 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n# 示例 1:# [https://assets.leetcode.com/uploads/2021/02/14/tree.jpg]\n# 输入: [1,2,3,null,5,null,4]\n# 输出: [1,3,4]# 示例 2:# 输入: [1,null,3]# 输出: [1,3]# 示例 3:# 输入: []# 输出: []# 提示:#  * 二叉树的节点个数的范围是 [0,100]#  * -100 <= Node.val <= 100 \n"
    },
    {
        "name": "average_of_levels_in_binary_tree",
        "url": "https://leetcode.cn/problems/average-of-levels-in-binary-tree/description",
        "title": "637. 二叉树的层平均值 - 力扣（LeetCode）",
        "content": "# 637. 二叉树的层平均值 - 给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg]\n# 输入：root = [3,9,20,null,null,15,7]\n# 输出：[3.00000,14.50000,11.00000]\n# 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n# 因此返回 [3, 14.5, 11] 。# 示例 2:# [https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg]\n# 输入：root = [3,9,20,15,7]# 输出：[3.00000,14.50000,11.00000]\n# 提示：#  * 树中节点数量在 [1, 104] 范围内#  * -231 <= Node.val <= 231 - 1\n"
    },
    {
        "name": "binary_tree_level_order_traversal",
        "url": "https://leetcode.cn/problems/binary-tree-level-order-traversal/description",
        "title": "102. 二叉树的层序遍历 - 力扣（LeetCode）",
        "content": "# 102. 二叉树的层序遍历 - 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg]\n# 输入：root = [3,9,20,null,null,15,7]\n# 输出：[[3],[9,20],[15,7]]# 示例 2：# 输入：root = [1]# 输出：[[1]]# 示例 3：# 输入：root = []# 输出：[]# 提示：#  * 树中节点数目在范围 [0, 2000] 内\n#  * -1000 <= Node.val <= 1000\n"
    },
    {
        "name": "binary_tree_zigzag_level_order_traversal",
        "url": "https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description",
        "title": "103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）",
        "content": "# 103. 二叉树的锯齿形层序遍历 - 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg]\n# 输入：root = [3,9,20,null,null,15,7]\n# 输出：[[3],[20,9],[15,7]]# 示例 2：# 输入：root = [1]# 输出：[[1]]# 示例 3：# 输入：root = []# 输出：[]# 提示：#  * 树中节点数目在范围 [0, 2000] 内\n#  * -100 <= Node.val <= 100\n"
    },
    {
        "name": "minimum_absolute_difference_in_bst",
        "url": "https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description",
        "title": "530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）",
        "content": "# 530. 二叉搜索树的最小绝对差 - 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\n# 差值是一个正数，其数值等于两值之差的绝对值。# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg]\n# 输入：root = [4,2,6,1,3]# 输出：1# 示例 2：# [https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg]\n# 输入：root = [1,0,48,null,null,12,49]\n# 输出：1# 提示：#  * 树中节点的数目范围是 [2, 104]#  * 0 <= Node.val <= 105# 注意：本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ [https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/] 相同\n"
    },
    {
        "name": "kth_smallest_element_in_a_bst",
        "url": "https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description",
        "title": "230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）",
        "content": "# 230. 二叉搜索树中第K小的元素 - 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg]\n# 输入：root = [3,1,4,null,2], k = 1\n# 输出：1# 示例 2：# [https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg]\n# 输入：root = [5,3,6,2,4,null,null,1], k = 3\n# 输出：3# 提示：#  * 树中的节点数为 n 。#  * 1 <= k <= n <= 104#  * 0 <= Node.val <= 104# 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\n"
    },
    {
        "name": "validate_binary_search_tree",
        "url": "https://leetcode.cn/problems/validate-binary-search-tree/description",
        "title": "98. 验证二叉搜索树 - 力扣（LeetCode）",
        "content": "# 98. 验证二叉搜索树 - 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n# 有效 二叉搜索树定义如下：#  * 节点的左子树只包含 小于 当前节点的数。#  * 节点的右子树只包含 大于 当前节点的数。#  * 所有左子树和右子树自身必须也是二叉搜索树。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg]\n# 输入：root = [2,1,3]# 输出：true# 示例 2：# [https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg]\n# 输入：root = [5,1,4,null,null,3,6]\n# 输出：false# 解释：根节点的值是 5 ，但是右子节点的值是 4 。\n# 提示：#  * 树中节点数目范围在[1, 104] 内#  * -231 <= Node.val <= 231 - 1\n"
    },
    {
        "name": "number_of_islands",
        "url": "https://leetcode.cn/problems/number-of-islands/description",
        "title": "200. 岛屿数量 - 力扣（LeetCode）",
        "content": "# 200. 岛屿数量 - 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n# 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n# 此外，你可以假设该网格的四条边均被水包围。# 示例 1：# 输入：grid = [#   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n#   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n#   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n#   [\"0\",\"0\",\"0\",\"0\",\"0\"]# ]# 输出：1# 示例 2：# 输入：grid = [#   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n#   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n#   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n#   [\"0\",\"0\",\"0\",\"1\",\"1\"]# ]# 输出：3# 提示：#  * m == grid.length#  * n == grid[i].length#  * 1 <= m, n <= 300#  * grid[i][j] 的值为 '0' 或 '1'\n"
    },
    {
        "name": "surrounded_regions",
        "url": "https://leetcode.cn/problems/surrounded-regions/description",
        "title": "130. 被围绕的区域 - 力扣（LeetCode）",
        "content": "# 130. 被围绕的区域 - 给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg]\n# 输入：board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n# 输出：[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n# 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n# 示例 2：# 输入：board = [[\"X\"]]# 输出：[[\"X\"]]# 提示：#  * m == board.length#  * n == board[i].length#  * 1 <= m, n <= 200#  * board[i][j] 为 'X' 或 'O'\n"
    },
    {
        "name": "clone_graph",
        "url": "https://leetcode.cn/problems/clone-graph/description",
        "title": "133. 克隆图 - 力扣（LeetCode）",
        "content": "# 133. 克隆图 - 给你无向 连通 [https://baike.baidu.com/item/连通图/6460995?fr=aladdin] 图中一个节点的引用，请你返回该图的 深拷贝 [https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin]（克隆）。\n# 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。\n# class Node {#     public int val;#     public List<Node> neighbors;\n# }# 测试用例格式：# 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。\n# 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n# 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。\n# 示例 1：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png]\n# 输入：adjList = [[2,4],[1,3],[2,4],[1,3]]\n# 输出：[[2,4],[1,3],[2,4],[1,3]]\n# 解释：# 图中有 4 个节点。# 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n# 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n# 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n# 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n# 示例 2：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png]\n# 输入：adjList = [[]]# 输出：[[]]# 解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n# 示例 3：# 输入：adjList = []# 输出：[]# 解释：这个图是空的，它不含任何节点。# 示例 4：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png]\n# 输入：adjList = [[2],[1]]# 输出：[[2],[1]]# 提示：#  1. 节点数不超过 100 。#  2. 每个节点值 Node.val 都是唯一的，1 <= Node.val <= 100。\n#  3. 无向图是一个简单图 [https://baike.baidu.com/item/简单图/1680528?fr=aladdin]，这意味着图中没有重复的边，也没有自环。\n#  4. 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。\n#  5. 图是连通图，你可以从给定节点访问到所有节点。\n"
    },
    {
        "name": "evaluate_division",
        "url": "https://leetcode.cn/problems/evaluate-division/description",
        "title": "399. 除法求值 - 力扣（LeetCode）",
        "content": "# 399. 除法求值 - 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。\n# 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。\n# 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。\n# 注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。\n# 注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。\n# 示例 1：# 输入：equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n# 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n# 解释：# 条件：a / b = 2.0, b / c = 3.0\n# 问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\n# 结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n# 注意：x 是未定义的 => -1.0# 示例 2：# 输入：equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n# 输出：[3.75000,0.40000,5.00000,0.20000]\n# 示例 3：# 输入：equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n# 输出：[0.50000,2.00000,-1.00000,-1.00000]\n# 提示：#  * 1 <= equations.length <= 20\n#  * equations[i].length == 2\n#  * 1 <= Ai.length, Bi.length <= 5\n#  * values.length == equations.length\n#  * 0.0 < values[i] <= 20.0\n#  * 1 <= queries.length <= 20\n#  * queries[i].length == 2\n#  * 1 <= Cj.length, Dj.length <= 5\n#  * Ai, Bi, Cj, Dj 由小写英文字母与数字组成\n"
    },
    {
        "name": "course_schedule",
        "url": "https://leetcode.cn/problems/course-schedule/description",
        "title": "207. 课程表 - 力扣（LeetCode）",
        "content": "# 207. 课程表 - 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。\n# 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。\n#  * 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。\n# 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\n# 示例 1：# 输入：numCourses = 2, prerequisites = [[1,0]]\n# 输出：true# 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。\n# 示例 2：# 输入：numCourses = 2, prerequisites = [[1,0],[0,1]]\n# 输出：false# 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。\n# 提示：#  * 1 <= numCourses <= 2000\n#  * 0 <= prerequisites.length <= 5000\n#  * prerequisites[i].length == 2\n#  * 0 <= ai, bi < numCourses\n#  * prerequisites[i] 中的所有课程对 互不相同\n"
    },
    {
        "name": "course_schedule_ii",
        "url": "https://leetcode.cn/problems/course-schedule-ii/description",
        "title": "210. 课程表 II - 力扣（LeetCode）",
        "content": "# 210. 课程表 II - 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。\n#  * 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。\n# 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。\n# 示例 1：# 输入：numCourses = 2, prerequisites = [[1,0]]\n# 输出：[0,1]# 解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。\n# 示例 2：# 输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n# 输出：[0,2,1,3]# 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n# 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n# 示例 3：# 输入：numCourses = 1, prerequisites = []\n# 输出：[0]# 提示：#  * 1 <= numCourses <= 2000\n#  * 0 <= prerequisites.length <= numCourses * (numCourses - 1)\n#  * prerequisites[i].length == 2\n#  * 0 <= ai, bi < numCourses\n#  * ai != bi#  * 所有[ai, bi] 互不相同"
    },
    {
        "name": "snakes_and_ladders",
        "url": "https://leetcode.cn/problems/snakes-and-ladders/description",
        "title": "909. 蛇梯棋 - 力扣（LeetCode）",
        "content": "# 909. 蛇梯棋 - 给你一个大小为 n x n 的整数矩阵 board ，方格按从 1 到 n2 编号，编号遵循 转行交替方式 [https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/17195786] ，从左下角开始 （即，从 board[n - 1][0] 开始）每一行交替方向。\n# 玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。\n# 每一回合，玩家需要从当前方格 curr 开始出发，按下述要求前进：\n#  * 选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n2)] 。\n#    * 该选择模拟了掷 六面体骰子 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。\n#  * 传送玩家：如果目标方格 next 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 next 。 \n#  * 当玩家到达编号 n2 的方格时，游戏结束。\n# r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。编号为 1 和 n2 的方格上没有蛇或梯子。\n# 注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 不能 继续移动。\n#  * 举个例子，假设棋盘是 [[-1,4],[-1,3]] ，第一次移动，玩家的目标方格是 2 。那么这个玩家将会顺着梯子到达方格 3 ，但 不能 顺着方格 3 上的梯子前往方格 4 。\n# 返回达到编号为 n2 的方格所需的最少移动次数，如果不可能，则返回 -1。\n# 示例 1：# [https://assets.leetcode.com/uploads/2018/09/23/snakes.png]\n# 输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\n# 输出：4# 解释：# 首先，从方格 1 [第 5 行，第 0 列] 开始。 \n# 先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。\n# 然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。\n# 接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 \n# 最后决定移动到方格 36 , 游戏结束。 # 可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 \n# 示例 2：# 输入：board = [[-1,-1],[-1,3]]\n# 输出：1# 提示：#  * n == board.length == board[i].length\n#  * 2 <= n <= 20#  * grid[i][j] 的值是 -1 或在范围 [1, n2] 内\n#  * 编号为 1 和 n2 的方格上没有蛇或梯子\n"
    },
    {
        "name": "minimum_genetic_mutation",
        "url": "https://leetcode.cn/problems/minimum-genetic-mutation/description",
        "title": "433. 最小基因变化 - 力扣（LeetCode）",
        "content": "# 433. 最小基因变化 - 基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。\n# 假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。\n#  * 例如，\"AACCGGTT\" --> \"AACCGGTA\" 就是一次基因变化。\n# 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）\n# 给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。\n# 注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。\n# 示例 1：# 输入：start = \"AACCGGTT\", end = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n# 输出：1# 示例 2：# 输入：start = \"AACCGGTT\", end = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n# 输出：2# 示例 3：# 输入：start = \"AAAAACCC\", end = \"AACCCCCC\", bank = [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"]\n# 输出：3# 提示：#  * start.length == 8#  * end.length == 8#  * 0 <= bank.length <= 10\n#  * bank[i].length == 8#  * start、end 和 bank[i] 仅由字符 ['A', 'C', 'G', 'T'] 组成\n"
    },
    {
        "name": "word_ladder",
        "url": "https://leetcode.cn/problems/word-ladder/description",
        "title": "127. 单词接龙 - 力扣（LeetCode）",
        "content": "# 127. 单词接龙 - 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：\n#  * 每一对相邻的单词只差一个字母。#  *  对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。\n#  * sk == endWord# 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。\n# 示例 1：# 输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n# 输出：5# 解释：一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。\n# 示例 2：# 输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n# 输出：0# 解释：endWord \"cog\" 不在字典中，所以无法进行转换。\n# 提示：#  * 1 <= beginWord.length <= 10\n#  * endWord.length == beginWord.length\n#  * 1 <= wordList.length <= 5000\n#  * wordList[i].length == beginWord.length\n#  * beginWord、endWord 和 wordList[i] 由小写英文字母组成\n#  * beginWord != endWord#  * wordList 中的所有字符串 互不相同\n"
    },
    {
        "name": "implement_trie_prefix_tree",
        "url": "https://leetcode.cn/problems/implement-trie-prefix-tree/description",
        "title": "208. 实现 Trie (前缀树) - 力扣（LeetCode）",
        "content": "# 208. 实现 Trie (前缀树) - Trie [https://baike.baidu.com/item/字典树/9825209?fr=aladdin]（发音类似 \"try\"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n# 请你实现 Trie 类：#  * Trie() 初始化前缀树对象。#  * void insert(String word) 向前缀树中插入字符串 word 。\n#  * boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\n#  * boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n# 示例：# 输入# [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n# [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n# 输出# [null, null, true, false, true, null, true]\n# 解释# Trie trie = new Trie();# trie.insert(\"apple\");# trie.search(\"apple\");   // 返回 True\n# trie.search(\"app\");     // 返回 False\n# trie.startsWith(\"app\"); // 返回 True\n# trie.insert(\"app\");# trie.search(\"app\");     // 返回 True\n# 提示：#  * 1 <= word.length, prefix.length <= 2000\n#  * word 和 prefix 仅由小写英文字母组成\n#  * insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次\n"
    },
    {
        "name": "design_add_and_search_words_data_structure",
        "url": "https://leetcode.cn/problems/design-add-and-search-words-data-structure/description",
        "title": "211. 添加与搜索单词 - 数据结构设计 - 力扣（LeetCode）",
        "content": "# 211. 添加与搜索单词 - 数据结构设计 - 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n# 实现词典类 WordDictionary ：#  * WordDictionary() 初始化词典对象\n#  * void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配\n#  * bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。\n# 示例：# 输入：# [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n# [[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n# 输出：# [null,null,null,null,false,true,true,true]\n# 解释：# WordDictionary wordDictionary = new WordDictionary();\n# wordDictionary.addWord(\"bad\");\n# wordDictionary.addWord(\"dad\");\n# wordDictionary.addWord(\"mad\");\n# wordDictionary.search(\"pad\"); // 返回 False\n# wordDictionary.search(\"bad\"); // 返回 True\n# wordDictionary.search(\".ad\"); // 返回 True\n# wordDictionary.search(\"b..\"); // 返回 True\n# 提示：#  * 1 <= word.length <= 25\n#  * addWord 中的 word 由小写英文字母组成\n#  * search 中的 word 由 '.' 或小写英文字母组成\n#  * 最多调用 104 次 addWord 和 search\n"
    },
    {
        "name": "word_search_ii",
        "url": "https://leetcode.cn/problems/word-search-ii/description",
        "title": "212. 单词搜索 II - 力扣（LeetCode）",
        "content": "# 212. 单词搜索 II - 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。\n# 单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/07/search1.jpg]\n# 输入：board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n# 输出：[\"eat\",\"oath\"]# 示例 2：# [https://assets.leetcode.com/uploads/2020/11/07/search2.jpg]\n# 输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n# 输出：[]# 提示：#  * m == board.length#  * n == board[i].length#  * 1 <= m, n <= 12#  * board[i][j] 是一个小写英文字母\n#  * 1 <= words.length <= 3 * 104\n#  * 1 <= words[i].length <= 10\n#  * words[i] 由小写英文字母组成#  * words 中的所有字符串互不相同"
    },
    {
        "name": "letter_combinations_of_a_phone_number",
        "url": "https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description",
        "title": "17. 电话号码的字母组合 - 力扣（LeetCode）",
        "content": "# 17. 电话号码的字母组合 - 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n# 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png]\n# 示例 1：# 输入：digits = \"23\"# 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n# 示例 2：# 输入：digits = \"\"# 输出：[]# 示例 3：# 输入：digits = \"2\"# 输出：[\"a\",\"b\",\"c\"]# 提示：#  * 0 <= digits.length <= 4\n#  * digits[i] 是范围 ['2', '9'] 的一个数字。\n"
    },
    {
        "name": "combinations",
        "url": "https://leetcode.cn/problems/combinations/description",
        "title": "77. 组合 - 力扣（LeetCode）",
        "content": "# 77. 组合 - 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n# 你可以按 任何顺序 返回答案。# 示例 1：# 输入：n = 4, k = 2# 输出：# [#   [2,4],#   [3,4],#   [2,3],#   [1,2],#   [1,3],#   [1,4],# ]# 示例 2：# 输入：n = 1, k = 1# 输出：[[1]]# 提示：#  * 1 <= n <= 20#  * 1 <= k <= n"
    },
    {
        "name": "permutations",
        "url": "https://leetcode.cn/problems/permutations/description",
        "title": "46. 全排列 - 力扣（LeetCode）",
        "content": "# 46. 全排列 - 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n# 示例 1：# 输入：nums = [1,2,3]# 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n# 示例 2：# 输入：nums = [0,1]# 输出：[[0,1],[1,0]]# 示例 3：# 输入：nums = [1]# 输出：[[1]]# 提示：#  * 1 <= nums.length <= 6\n#  * -10 <= nums[i] <= 10#  * nums 中的所有整数 互不相同"
    },
    {
        "name": "combination_sum",
        "url": "https://leetcode.cn/problems/combination-sum/description",
        "title": "39. 组合总和 - 力扣（LeetCode）",
        "content": "# 39. 组合总和 - 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n# candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n# 对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n# 示例 1：# 输入：candidates = [2,3,6,7], target = 7\n# 输出：[[2,2,3],[7]]# 解释：# 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n# 7 也是一个候选， 7 = 7 。# 仅有这两种组合。# 示例 2：# 输入: candidates = [2,3,5], target = 8\n# 输出: [[2,2,2,2],[2,3,3],[3,5]]\n# 示例 3：# 输入: candidates = [2], target = 1\n# 输出: []# 提示：#  * 1 <= candidates.length <= 30\n#  * 2 <= candidates[i] <= 40\n#  * candidates 的所有元素 互不相同\n#  * 1 <= target <= 40"
    },
    {
        "name": "n_queens_ii",
        "url": "https://leetcode.cn/problems/n-queens-ii/description",
        "title": "52. N 皇后 II - 力扣（LeetCode）",
        "content": "# 52. N 皇后 II - n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n# 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/13/queens.jpg]\n# 输入：n = 4# 输出：2# 解释：如上图所示，4 皇后问题存在两个不同的解法。\n# 示例 2：# 输入：n = 1# 输出：1# 提示：#  * 1 <= n <= 9"
    },
    {
        "name": "generate_parentheses",
        "url": "https://leetcode.cn/problems/generate-parentheses/description",
        "title": "22. 括号生成 - 力扣（LeetCode）",
        "content": "# 22. 括号生成 - 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n# 示例 1：# 输入：n = 3# 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n# 示例 2：# 输入：n = 1# 输出：[\"()\"]# 提示：#  * 1 <= n <= 8"
    },
    {
        "name": "word_search",
        "url": "https://leetcode.cn/problems/word-search/description",
        "title": "79. 单词搜索 - 力扣（LeetCode）",
        "content": "# 79. 单词搜索 - 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n# 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/04/word2.jpg]\n# 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n# 输出：true# 示例 2：# [https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg]\n# 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n# 输出：true# 示例 3：# [https://assets.leetcode.com/uploads/2020/10/15/word3.jpg]\n# 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n# 输出：false# 提示：#  * m == board.length#  * n = board[i].length#  * 1 <= m, n <= 6#  * 1 <= word.length <= 15\n#  * board 和 word 仅由大小写英文字母组成\n# 进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？\n"
    },
    {
        "name": "convert_sorted_array_to_binary_search_tree",
        "url": "https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description",
        "title": "108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）",
        "content": "# 108. 将有序数组转换为二叉搜索树 - 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg]\n# 输入：nums = [-10,-3,0,5,9]\n# 输出：[0,-3,9,-10,null,5]# 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n# [https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg]\n# 示例 2：# [https://assets.leetcode.com/uploads/2021/02/18/btree.jpg]\n# 输入：nums = [1,3]# 输出：[3,1]# 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。\n# 提示：#  * 1 <= nums.length <= 104\n#  * -104 <= nums[i] <= 104\n#  * nums 按 严格递增 顺序排列"
    },
    {
        "name": "sort_list",
        "url": "https://leetcode.cn/problems/sort-list/description",
        "title": "148. 排序链表 - 力扣（LeetCode）",
        "content": "# 148. 排序链表 - 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg]\n# 输入：head = [4,2,1,3]# 输出：[1,2,3,4]# 示例 2：# [https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg]\n# 输入：head = [-1,5,3,4,0]# 输出：[-1,0,3,4,5]# 示例 3：# 输入：head = []# 输出：[]# 提示：#  * 链表中节点的数目在范围 [0, 5 * 104] 内\n#  * -105 <= Node.val <= 105\n# 进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n"
    },
    {
        "name": "construct_quad_tree",
        "url": "https://leetcode.cn/problems/construct-quad-tree/description",
        "title": "427. 建立四叉树 - 力扣（LeetCode）",
        "content": "# 427. 建立四叉树 - 给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。\n# 你需要返回能表示矩阵 grid 的 四叉树 的根结点。\n# 四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：\n#  * val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False。注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。\n#  * isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。\n# class Node {#     public boolean val;#     public boolean isLeaf;\n#     public Node topLeft;\n#     public Node topRight;\n#     public Node bottomLeft;\n#     public Node bottomRight;\n# }# 我们可以按以下步骤为二维区域构建四叉树：#  1. 如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。\n#  2. 如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。\n#  3. 使用适当的子网格递归每个子节点。# [https://assets.leetcode.com/uploads/2020/02/11/new_top.png]\n# 如果你想了解更多关于四叉树的内容，可以参考 wiki [https://en.wikipedia.org/wiki/Quadtree] 。\n# 四叉树格式：# 你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中 null 表示路径终止符，其下面不存在节点。\n# 它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 [isLeaf, val] 。\n# 如果 isLeaf 或者 val 的值为 True ，则表示它在列表 [isLeaf, val] 中的值为 1 ；如果 isLeaf 或者 val 的值为 False ，则表示值为 0 。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/02/11/grid1.png]\n# 输入：grid = [[0,1],[1,0]]# 输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]\n# 解释：此示例的解释如下：# 请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。\n# [https://assets.leetcode.com/uploads/2020/02/12/e1tree.png]\n# 示例 2：# [https://assets.leetcode.com/uploads/2020/02/12/e2mat.png]\n# 输入：grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\n# 输出：[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n# 解释：网格中的所有值都不相同。我们将网格划分为四个子网格。\n# topLeft，bottomLeft 和 bottomRight 均具有相同的值。\n# topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。\n# 解释如下图所示：# [https://assets.leetcode.com/uploads/2020/02/12/e2tree.png]\n# 提示：#  1. n == grid.length == grid[i].length\n#  2. n == 2x 其中 0 <= x <= 6\n"
    },
    {
        "name": "merge_k_sorted_lists",
        "url": "https://leetcode.cn/problems/merge-k-sorted-lists/description",
        "title": "23. 合并 K 个升序链表 - 力扣（LeetCode）",
        "content": "# 23. 合并 K 个升序链表 - 给你一个链表数组，每个链表都已经按升序排列。\n# 请你将所有链表合并到一个升序链表中，返回合并后的链表。\n# 示例 1：# 输入：lists = [[1,4,5],[1,3,4],[2,6]]\n# 输出：[1,1,2,3,4,4,5,6]# 解释：链表数组如下：# [#   1->4->5,#   1->3->4,#   2->6# ]# 将它们合并到一个有序链表中得到。# 1->1->2->3->4->4->5->6# 示例 2：# 输入：lists = []# 输出：[]# 示例 3：# 输入：lists = [[]]# 输出：[]# 提示：#  * k == lists.length#  * 0 <= k <= 10^4#  * 0 <= lists[i].length <= 500\n#  * -10^4 <= lists[i][j] <= 10^4\n#  * lists[i] 按 升序 排列#  * lists[i].length 的总和不超过 10^4\n"
    },
    {
        "name": "maximum_subarray",
        "url": "https://leetcode.cn/problems/maximum-subarray/description",
        "title": "53. 最大子数组和 - 力扣（LeetCode）",
        "content": "# 53. 最大子数组和 - 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n# 子数组 是数组中的一个连续部分。# 示例 1：# 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n# 输出：6# 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n# 示例 2：# 输入：nums = [1]# 输出：1# 示例 3：# 输入：nums = [5,4,-1,7,8]# 输出：23# 提示：#  * 1 <= nums.length <= 105\n#  * -104 <= nums[i] <= 104\n# 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n"
    },
    {
        "name": "maximum_sum_circular_subarray",
        "url": "https://leetcode.cn/problems/maximum-sum-circular-subarray/description",
        "title": "918. 环形子数组的最大和 - 力扣（LeetCode）",
        "content": "# 918. 环形子数组的最大和 - 给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。\n# 环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。\n# 子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i <= k1, k2 <= j 其中 k1 % n == k2 % n 。\n# 示例 1：# 输入：nums = [1,-2,3,-2]# 输出：3# 解释：从子数组 [3] 得到最大和 3# 示例 2：# 输入：nums = [5,-3,5]# 输出：10# 解释：从子数组 [5,5] 得到最大和 5 + 5 = 10\n# 示例 3：# 输入：nums = [3,-2,2,-3]# 输出：3# 解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3\n# 提示：#  * n == nums.length#  * 1 <= n <= 3 * 104#  * -3 * 104 <= nums[i] <= 3 * 104\n"
    },
    {
        "name": "search_insert_position",
        "url": "https://leetcode.cn/problems/search-insert-position/description",
        "title": "35. 搜索插入位置 - 力扣（LeetCode）",
        "content": "# 35. 搜索插入位置 - 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n# 请必须使用时间复杂度为 O(log n) 的算法。\n# 示例 1:# 输入: nums = [1,3,5,6], target = 5\n# 输出: 2# 示例 2:# 输入: nums = [1,3,5,6], target = 2\n# 输出: 1# 示例 3:# 输入: nums = [1,3,5,6], target = 7\n# 输出: 4# 提示:#  * 1 <= nums.length <= 104\n#  * -104 <= nums[i] <= 104\n#  * nums 为 无重复元素 的 升序 排列数组\n#  * -104 <= target <= 104\n"
    },
    {
        "name": "search_a_2d_matrix",
        "url": "https://leetcode.cn/problems/search-a-2d-matrix/description",
        "title": "74. 搜索二维矩阵 - 力扣（LeetCode）",
        "content": "# 74. 搜索二维矩阵 - 给你一个满足下述两条属性的 m x n 整数矩阵：\n#  * 每行中的整数从左到右按非严格递增顺序排列。\n#  * 每行的第一个整数大于前一行的最后一个整数。\n# 给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/10/05/mat.jpg]\n# 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n# 输出：true# 示例 2：# [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg]\n# 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n# 输出：false# 提示：#  * m == matrix.length#  * n == matrix[i].length\n#  * 1 <= m, n <= 100#  * -104 <= matrix[i][j], target <= 104\n"
    },
    {
        "name": "find_peak_element",
        "url": "https://leetcode.cn/problems/find-peak-element/description",
        "title": "162. 寻找峰值 - 力扣（LeetCode）",
        "content": "# 162. 寻找峰值 - 峰值元素是指其值严格大于左右相邻值的元素。\n# 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n# 你可以假设 nums[-1] = nums[n] = -∞ 。\n# 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n# 示例 1：# 输入：nums = [1,2,3,1]# 输出：2# 解释：3 是峰值元素，你的函数应该返回其索引 2。\n# 示例 2：# 输入：nums = [1,2,1,3,5,6,4]\n# 输出：1 或 5 # 解释：你的函数可以返回索引 1，其峰值元素为 2；\n#      或者返回索引 5， 其峰值元素为 6。\n# 提示：#  * 1 <= nums.length <= 1000\n#  * -231 <= nums[i] <= 231 - 1\n#  * 对于所有有效的 i 都有 nums[i] != nums[i + 1]\n"
    },
    {
        "name": "search_in_rotated_sorted_array",
        "url": "https://leetcode.cn/problems/search-in-rotated-sorted-array/description",
        "title": "33. 搜索旋转排序数组 - 力扣（LeetCode）",
        "content": "# 33. 搜索旋转排序数组 - 整数数组 nums 按升序排列，数组中的值 互不相同 。\n# 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n# 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n# 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n# 示例 1：# 输入：nums = [4,5,6,7,0,1,2], target = 0\n# 输出：4# 示例 2：# 输入：nums = [4,5,6,7,0,1,2], target = 3\n# 输出：-1# 示例 3：# 输入：nums = [1], target = 0\n# 输出：-1# 提示：#  * 1 <= nums.length <= 5000\n#  * -104 <= nums[i] <= 104\n#  * nums 中的每个值都 独一无二#  * 题目数据保证 nums 在预先未知的某个下标上进行了旋转\n#  * -104 <= target <= 104\n"
    },
    {
        "name": "find_first_and_last_position_of_element_in_sorted_array",
        "url": "https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description",
        "title": "34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）",
        "content": "# 34. 在排序数组中查找元素的第一个和最后一个位置 - 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n# 如果数组中不存在目标值 target，返回 [-1, -1]。\n# 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n# 示例 1：# 输入：nums = [5,7,7,8,8,10], target = 8\n# 输出：[3,4]# 示例 2：# 输入：nums = [5,7,7,8,8,10], target = 6\n# 输出：[-1,-1]# 示例 3：# 输入：nums = [], target = 0\n# 输出：[-1,-1]# 提示：#  * 0 <= nums.length <= 105\n#  * -109 <= nums[i] <= 109\n#  * nums 是一个非递减数组#  * -109 <= target <= 109\n"
    },
    {
        "name": "find_minimum_in_rotated_sorted_array",
        "url": "https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description",
        "title": "153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）",
        "content": "# 153. 寻找旋转排序数组中的最小值 - 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n#  * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n#  * 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n# 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n# 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n# 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n# 示例 1：# 输入：nums = [3,4,5,1,2]# 输出：1# 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n# 示例 2：# 输入：nums = [4,5,6,7,0,1,2]\n# 输出：0# 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。\n# 示例 3：# 输入：nums = [11,13,15,17]# 输出：11# 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n# 提示：#  * n == nums.length#  * 1 <= n <= 5000#  * -5000 <= nums[i] <= 5000\n#  * nums 中的所有整数 互不相同#  * nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n"
    },
    {
        "name": "median_of_two_sorted_arrays",
        "url": "https://leetcode.cn/problems/median-of-two-sorted-arrays/description",
        "title": "4. 寻找两个正序数组的中位数 - 力扣（LeetCode）",
        "content": "# 4. 寻找两个正序数组的中位数 - 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n# 算法的时间复杂度应该为 O(log (m+n)) 。\n# 示例 1：# 输入：nums1 = [1,3], nums2 = [2]\n# 输出：2.00000# 解释：合并数组 = [1,2,3] ，中位数 2\n# 示例 2：# 输入：nums1 = [1,2], nums2 = [3,4]\n# 输出：2.50000# 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n# 提示：#  * nums1.length == m#  * nums2.length == n#  * 0 <= m <= 1000#  * 0 <= n <= 1000#  * 1 <= m + n <= 2000#  * -106 <= nums1[i], nums2[i] <= 106\n"
    },
    {
        "name": "kth_largest_element_in_an_array",
        "url": "https://leetcode.cn/problems/kth-largest-element-in-an-array/description",
        "title": "215. 数组中的第K个最大元素 - 力扣（LeetCode）",
        "content": "# 215. 数组中的第K个最大元素 - 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n# 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n# 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n# 示例 1:# 输入: [3,2,1,5,6,4], k = 2\n# 输出: 5# 示例 2:# 输入: [3,2,3,1,2,4,5,5,6], k = 4\n# 输出: 4# 提示：#  * 1 <= k <= nums.length <= 105\n#  * -104 <= nums[i] <= 104\n"
    },
    {
        "name": "ipo",
        "url": "https://leetcode.cn/problems/ipo/description",
        "title": "502. IPO - 力扣（LeetCode）",
        "content": "# 502. IPO - 假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。\n# 给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。\n# 最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。\n# 总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。\n# 答案保证在 32 位有符号整数范围内。# 示例 1：# 输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n# 输出：4# 解释：# 由于你的初始资本为 0，你仅可以从 0 号项目开始。\n# 在完成后，你将获得 1 的利润，你的总资本将变为 1。\n# 此时你可以选择开始 1 号或 2 号项目。# 由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。\n# 因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。\n# 示例 2：# 输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n# 输出：6# 提示：#  * 1 <= k <= 105#  * 0 <= w <= 109#  * n == profits.length#  * n == capital.length#  * 1 <= n <= 105#  * 0 <= profits[i] <= 104\n#  * 0 <= capital[i] <= 109\n"
    },
    {
        "name": "find_k_pairs_with_smallest_sums",
        "url": "https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description",
        "title": "373. 查找和最小的 K 对数字 - 力扣（LeetCode）",
        "content": "# 373. 查找和最小的 K 对数字 - 给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。\n# 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。\n# 请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。\n# 示例 1:# 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n# 输出: [1,2],[1,4],[1,6]# 解释: 返回序列中的前 3 对数：#      [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n# 示例 2:# 输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n# 输出: [1,1],[1,1]# 解释: 返回序列中的前 2 对数：#      [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n# 提示:#  * 1 <= nums1.length, nums2.length <= 105\n#  * -109 <= nums1[i], nums2[i] <= 109\n#  * nums1 和 nums2 均为 升序排列\n#  * 1 <= k <= 104#  * k <= nums1.length * nums2.length\n"
    },
    {
        "name": "find_median_from_data_stream",
        "url": "https://leetcode.cn/problems/find-median-from-data-stream/description",
        "title": "295. 数据流的中位数 - 力扣（LeetCode）",
        "content": "# 295. 数据流的中位数 - 中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。\n#  * 例如 arr = [2,3,4] 的中位数是 3 。\n#  * 例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。\n# 实现 MedianFinder 类:#  * MedianFinder() 初始化 MedianFinder 对象。\n#  * void addNum(int num) 将数据流中的整数 num 添加到数据结构中。\n#  * double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。\n# 示例 1：# 输入# [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n# [[], [1], [2], [], [3], []]\n# 输出# [null, null, null, 1.5, null, 2.0]\n# 解释# MedianFinder medianFinder = new MedianFinder();\n# medianFinder.addNum(1);    // arr = [1]\n# medianFinder.addNum(2);    // arr = [1, 2]\n# medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)\n# medianFinder.addNum(3);    // arr[1, 2, 3]\n# medianFinder.findMedian(); // return 2.0\n# 提示:#  * -105 <= num <= 105#  * 在调用 findMedian 之前，数据结构中至少有一个元素\n#  * 最多 5 * 104 次调用 addNum 和 findMedian\n"
    },
    {
        "name": "add_binary",
        "url": "https://leetcode.cn/problems/add-binary/description",
        "title": "67. 二进制求和 - 力扣（LeetCode）",
        "content": "# 67. 二进制求和 - 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。\n# 示例 1：# 输入:a = \"11\", b = \"1\"# 输出：\"100\"# 示例 2：# 输入：a = \"1010\", b = \"1011\"\n# 输出：\"10101\"# 提示：#  * 1 <= a.length, b.length <= 104\n#  * a 和 b 仅由字符 '0' 或 '1' 组成\n#  * 字符串如果不是 \"0\" ，就不含前导零"
    },
    {
        "name": "reverse_bits",
        "url": "https://leetcode.cn/problems/reverse-bits/description",
        "title": "190. 颠倒二进制位 - 力扣（LeetCode）",
        "content": "# 190. 颠倒二进制位 - 颠倒给定的 32 位无符号整数的二进制位。\n# 提示：#  * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n#  * 在 Java 中，编译器使用二进制补码 [https://baike.baidu.com/item/二进制补码/5295284]记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。\n# 示例 1：# 输入：n = 00000010100101000001111010011100\n# 输出：964176192 (00111001011110000010100101000000)\n# 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n#      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n# 示例 2：# 输入：n = 11111111111111111111111111111101\n# 输出：3221225471 (10111111111111111111111111111111)\n# 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n#      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n# 提示：#  * 输入是一个长度为 32 的二进制字符串# 进阶: 如果多次调用这个函数，你将如何优化你的算法？\n"
    },
    {
        "name": "number_of_1_bits",
        "url": "https://leetcode.cn/problems/number-of-1-bits/description",
        "title": "191. 位1的个数 - 力扣（LeetCode）",
        "content": "# 191. 位1的个数 - 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中 设置位 的个数（也被称为汉明重量 [https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F]）。\n# 示例 1：# 输入：n = 11# 输出：3# 解释：输入的二进制串 1011 中，共有 3 个设置位。\n# 示例 2：# 输入：n = 128# 输出：1# 解释：输入的二进制串 10000000 中，共有 1 个设置位。\n# 示例 3：# 输入：n = 2147483645# 输出：30# 解释：输入的二进制串 11111111111111111111111111111101 中，共有 30 个设置位。\n# 提示：#  * 1 <= n <= 231 - 1# 进阶：#  * 如果多次调用这个函数，你将如何优化你的算法？\n"
    },
    {
        "name": "single_number",
        "url": "https://leetcode.cn/problems/single-number/description",
        "title": "136. 只出现一次的数字 - 力扣（LeetCode）",
        "content": "# 136. 只出现一次的数字 - 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n# 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n# 示例 1 ：# 输入：nums = [2,2,1]# 输出：1# 示例 2 ：# 输入：nums = [4,1,2,1,2]# 输出：4# 示例 3 ：# 输入：nums = [1]# 输出：1# 提示：#  * 1 <= nums.length <= 3 * 104\n#  * -3 * 104 <= nums[i] <= 3 * 104\n#  * 除了某个元素只出现一次以外，其余每个元素均出现两次。\n"
    },
    {
        "name": "single_number_ii",
        "url": "https://leetcode.cn/problems/single-number-ii/description",
        "title": "137. 只出现一次的数字 II - 力扣（LeetCode）",
        "content": "# 137. 只出现一次的数字 II - 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n# 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。\n# 示例 1：# 输入：nums = [2,2,3,2]# 输出：3# 示例 2：# 输入：nums = [0,1,0,1,0,1,99]\n# 输出：99# 提示：#  * 1 <= nums.length <= 3 * 104\n#  * -231 <= nums[i] <= 231 - 1\n#  * nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次\n"
    },
    {
        "name": "bitwise_and_of_numbers_range",
        "url": "https://leetcode.cn/problems/bitwise-and-of-numbers-range/description",
        "title": "201. 数字范围按位与 - 力扣（LeetCode）",
        "content": "# 201. 数字范围按位与 - 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。\n# 示例 1：# 输入：left = 5, right = 7# 输出：4# 示例 2：# 输入：left = 0, right = 0# 输出：0# 示例 3：# 输入：left = 1, right = 2147483647\n# 输出：0# 提示：#  * 0 <= left <= right <= 231 - 1\n"
    },
    {
        "name": "palindrome_number",
        "url": "https://leetcode.cn/problems/palindrome-number/description",
        "title": "9. 回文数 - 力扣（LeetCode）",
        "content": "# 9. 回文数 - 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n# 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n#  * 例如，121 是回文，而 123 不是。# 示例 1：# 输入：x = 121# 输出：true# 示例 2：# 输入：x = -121# 输出：false# 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n# 示例 3：# 输入：x = 10# 输出：false# 解释：从右向左读, 为 01 。因此它不是一个回文数。\n# 提示：#  * -231 <= x <= 231 - 1# 进阶：你能不将整数转为字符串来解决这个问题吗？"
    },
    {
        "name": "plus_one",
        "url": "https://leetcode.cn/problems/plus-one/description",
        "title": "66. 加一 - 力扣（LeetCode）",
        "content": "# 66. 加一 - 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。\n# 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n# 你可以假设除了整数 0 之外，这个整数不会以零开头。\n# 示例 1：# 输入：digits = [1,2,3]# 输出：[1,2,4]# 解释：输入数组表示数字 123。# 示例 2：# 输入：digits = [4,3,2,1]# 输出：[4,3,2,2]# 解释：输入数组表示数字 4321。# 示例 3：# 输入：digits = [0]# 输出：[1]# 提示：#  * 1 <= digits.length <= 100\n#  * 0 <= digits[i] <= 9"
    },
    {
        "name": "factorial_trailing_zeroes",
        "url": "https://leetcode.cn/problems/factorial-trailing-zeroes/description",
        "title": "172. 阶乘后的零 - 力扣（LeetCode）",
        "content": "# 172. 阶乘后的零 - 给定一个整数 n ，返回 n! 结果中尾随零的数量。\n# 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1\n# 示例 1：# 输入：n = 3# 输出：0# 解释：3! = 6 ，不含尾随 0# 示例 2：# 输入：n = 5# 输出：1# 解释：5! = 120 ，有一个尾随 0# 示例 3：# 输入：n = 0# 输出：0# 提示：#  * 0 <= n <= 104# 进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？\n"
    },
    {
        "name": "sqrtx",
        "url": "https://leetcode.cn/problems/sqrtx/description",
        "title": "69. x 的平方根  - 力扣（LeetCode）",
        "content": "# 69. x 的平方根  - 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n# 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n# 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n# 示例 1：# 输入：x = 4# 输出：2# 示例 2：# 输入：x = 8# 输出：2# 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n# 提示：#  * 0 <= x <= 231 - 1"
    },
    {
        "name": "powx_n",
        "url": "https://leetcode.cn/problems/powx-n/description",
        "title": "50. Pow(x, n) - 力扣（LeetCode）",
        "content": "# 50. Pow(x, n) - 实现 pow(x, n) [https://www.cplusplus.com/reference/valarray/pow/] ，即计算 x 的整数 n 次幂函数（即，xn ）。\n# 示例 1：# 输入：x = 2.00000, n = 10# 输出：1024.00000# 示例 2：# 输入：x = 2.10000, n = 3# 输出：9.26100# 示例 3：# 输入：x = 2.00000, n = -2# 输出：0.25000# 解释：2-2 = 1/22 = 1/4 = 0.25\n# 提示：#  * -100.0 < x < 100.0#  * -231 <= n <= 231-1#  * n 是一个整数#  * 要么 x 不为零，要么 n > 0 。#  * -104 <= xn <= 104"
    },
    {
        "name": "max_points_on_a_line",
        "url": "https://leetcode.cn/problems/max-points-on-a-line/description",
        "title": "149. 直线上最多的点数 - 力扣（LeetCode）",
        "content": "# 149. 直线上最多的点数 - 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。\n# 示例 1：# [https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg]\n# 输入：points = [[1,1],[2,2],[3,3]]\n# 输出：3# 示例 2：# [https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg]\n# 输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n# 输出：4# 提示：#  * 1 <= points.length <= 300\n#  * points[i].length == 2\n#  * -104 <= xi, yi <= 104\n#  * points 中的所有点 互不相同"
    },
    {
        "name": "climbing_stairs",
        "url": "https://leetcode.cn/problems/climbing-stairs/description",
        "title": "70. 爬楼梯 - 力扣（LeetCode）",
        "content": "# 70. 爬楼梯 - 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n# 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n# 示例 1：# 输入：n = 2# 输出：2# 解释：有两种方法可以爬到楼顶。# 1. 1 阶 + 1 阶# 2. 2 阶# 示例 2：# 输入：n = 3# 输出：3# 解释：有三种方法可以爬到楼顶。# 1. 1 阶 + 1 阶 + 1 阶# 2. 1 阶 + 2 阶# 3. 2 阶 + 1 阶# 提示：#  * 1 <= n <= 45"
    },
    {
        "name": "house_robber",
        "url": "https://leetcode.cn/problems/house-robber/description",
        "title": "198. 打家劫舍 - 力扣（LeetCode）",
        "content": "# 198. 打家劫舍 - 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n# 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n# 示例 1：# 输入：[1,2,3,1]# 输出：4# 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n#      偷窃到的最高金额 = 1 + 3 = 4 。\n# 示例 2：# 输入：[2,7,9,3,1]# 输出：12# 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n#      偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n# 提示：#  * 1 <= nums.length <= 100\n#  * 0 <= nums[i] <= 400"
    },
    {
        "name": "word_break",
        "url": "https://leetcode.cn/problems/word-break/description",
        "title": "139. 单词拆分 - 力扣（LeetCode）",
        "content": "# 139. 单词拆分 - 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。\n# 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n# 示例 1：# 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n# 输出: true# 解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n# 示例 2：# 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n# 输出: true# 解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n#      注意，你可以重复使用字典中的单词。# 示例 3：# 输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n# 输出: false# 提示：#  * 1 <= s.length <= 300#  * 1 <= wordDict.length <= 1000\n#  * 1 <= wordDict[i].length <= 20\n#  * s 和 wordDict[i] 仅由小写英文字母组成\n#  * wordDict 中的所有字符串 互不相同\n"
    },
    {
        "name": "coin_change",
        "url": "https://leetcode.cn/problems/coin-change/description",
        "title": "322. 零钱兑换 - 力扣（LeetCode）",
        "content": "# 322. 零钱兑换 - 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n# 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n# 你可以认为每种硬币的数量是无限的。# 示例 1：# 输入：coins = [1, 2, 5], amount = 11\n# 输出：3 # 解释：11 = 5 + 5 + 1# 示例 2：# 输入：coins = [2], amount = 3\n# 输出：-1# 示例 3：# 输入：coins = [1], amount = 0\n# 输出：0# 提示：#  * 1 <= coins.length <= 12\n#  * 1 <= coins[i] <= 231 - 1\n#  * 0 <= amount <= 104"
    },
    {
        "name": "longest_increasing_subsequence",
        "url": "https://leetcode.cn/problems/longest-increasing-subsequence/description",
        "title": "300. 最长递增子序列 - 力扣（LeetCode）",
        "content": "# 300. 最长递增子序列 - 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n# 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n# 示例 1：# 输入：nums = [10,9,2,5,3,7,101,18]\n# 输出：4# 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n# 示例 2：# 输入：nums = [0,1,0,3,2,3]# 输出：4# 示例 3：# 输入：nums = [7,7,7,7,7,7,7]\n# 输出：1# 提示：#  * 1 <= nums.length <= 2500\n#  * -104 <= nums[i] <= 104\n# 进阶：#  * 你能将算法的时间复杂度降低到 O(n log(n)) 吗?\n"
    },
    {
        "name": "triangle",
        "url": "https://leetcode.cn/problems/triangle/description",
        "title": "120. 三角形最小路径和 - 力扣（LeetCode）",
        "content": "# 120. 三角形最小路径和 - 给定一个三角形 triangle ，找出自顶向下的最小路径和。\n# 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n# 示例 1：# 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n# 输出：11# 解释：如下面简图所示：#    2#   3 4#  6 5 7# 4 1 8 3# 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n# 示例 2：# 输入：triangle = [[-10]]# 输出：-10# 提示：#  * 1 <= triangle.length <= 200\n#  * triangle[0].length == 1\n#  * triangle[i].length == triangle[i - 1].length + 1\n#  * -104 <= triangle[i][j] <= 104\n# 进阶：#  * 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？\n"
    },
    {
        "name": "minimum_path_sum",
        "url": "https://leetcode.cn/problems/minimum-path-sum/description",
        "title": "64. 最小路径和 - 力扣（LeetCode）",
        "content": "# 64. 最小路径和 - 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n# 说明：每次只能向下或者向右移动一步。# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg]\n# 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n# 输出：7# 解释：因为路径 1→3→1→1→1 的总和最小。\n# 示例 2：# 输入：grid = [[1,2,3],[4,5,6]]\n# 输出：12# 提示：#  * m == grid.length#  * n == grid[i].length#  * 1 <= m, n <= 200#  * 0 <= grid[i][j] <= 200\n"
    },
    {
        "name": "unique_paths_ii",
        "url": "https://leetcode.cn/problems/unique-paths-ii/description",
        "title": "63. 不同路径 II - 力扣（LeetCode）",
        "content": "# 63. 不同路径 II - 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n# 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n# 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n# 网格中的障碍物和空位置分别用 1 和 0 来表示。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg]\n# 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n# 输出：2# 解释：3x3 网格的正中间有一个障碍物。# 从左上角到右下角一共有 2 条不同的路径：# 1. 向右 -> 向右 -> 向下 -> 向下# 2. 向下 -> 向下 -> 向右 -> 向右# 示例 2：# [https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg]\n# 输入：obstacleGrid = [[0,1],[0,0]]\n# 输出：1# 提示：#  * m == obstacleGrid.length\n#  * n == obstacleGrid[i].length\n#  * 1 <= m, n <= 100#  * obstacleGrid[i][j] 为 0 或 1\n"
    },
    {
        "name": "longest_palindromic_substring",
        "url": "https://leetcode.cn/problems/longest-palindromic-substring/description",
        "title": "5. 最长回文子串 - 力扣（LeetCode）",
        "content": "# 5. 最长回文子串 - 给你一个字符串 s，找到 s 中最长的回文子串。\n# 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n# 示例 1：# 输入：s = \"babad\"# 输出：\"bab\"# 解释：\"aba\" 同样是符合题意的答案。# 示例 2：# 输入：s = \"cbbd\"# 输出：\"bb\"# 提示：#  * 1 <= s.length <= 1000\n#  * s 仅由数字和英文字母组成"
    },
    {
        "name": "interleaving_string",
        "url": "https://leetcode.cn/problems/interleaving-string/description",
        "title": "97. 交错字符串 - 力扣（LeetCode）",
        "content": "# 97. 交错字符串 - 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。\n# 两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：\n#  * s = s1 + s2 + ... + sn\n#  * t = t1 + t2 + ... + tm\n#  * |n - m| <= 1#  * 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...\n# 注意：a + b 意味着字符串 a 和 b 连接。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg]\n# 输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n# 输出：true# 示例 2：# 输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n# 输出：false# 示例 3：# 输入：s1 = \"\", s2 = \"\", s3 = \"\"\n# 输出：true# 提示：#  * 0 <= s1.length, s2.length <= 100\n#  * 0 <= s3.length <= 200\n#  * s1、s2、和 s3 都由小写英文字母组成\n# 进阶：您能否仅使用 O(s2.length) 额外的内存空间来解决它?\n"
    },
    {
        "name": "edit_distance",
        "url": "https://leetcode.cn/problems/edit-distance/description",
        "title": "72. 编辑距离 - 力扣（LeetCode）",
        "content": "# 72. 编辑距离 - 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。\n# 你可以对一个单词进行如下三种操作：#  * 插入一个字符#  * 删除一个字符#  * 替换一个字符# 示例 1：# 输入：word1 = \"horse\", word2 = \"ros\"\n# 输出：3# 解释：# horse -> rorse (将 'h' 替换为 'r')\n# rorse -> rose (删除 'r')# rose -> ros (删除 'e')# 示例 2：# 输入：word1 = \"intention\", word2 = \"execution\"\n# 输出：5# 解释：# intention -> inention (删除 't')\n# inention -> enention (将 'i' 替换为 'e')\n# enention -> exention (将 'n' 替换为 'x')\n# exention -> exection (将 'n' 替换为 'c')\n# exection -> execution (插入 'u')\n# 提示：#  * 0 <= word1.length, word2.length <= 500\n#  * word1 和 word2 由小写英文字母组成\n"
    },
    {
        "name": "best_time_to_buy_and_sell_stock_iii",
        "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description",
        "title": "123. 买卖股票的最佳时机 III - 力扣（LeetCode）",
        "content": "# 123. 买卖股票的最佳时机 III - 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n# 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n# 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n# 示例 1:# 输入：prices = [3,3,5,0,0,3,1,4]\n# 输出：6# 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n#      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n# 示例 2：# 输入：prices = [1,2,3,4,5]# 输出：4# 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n#      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n#      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n# 示例 3：# 输入：prices = [7,6,4,3,1] \n# 输出：0 # 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\n# 示例 4：# 输入：prices = [1]# 输出：0# 提示：#  * 1 <= prices.length <= 105\n#  * 0 <= prices[i] <= 105\n"
    },
    {
        "name": "best_time_to_buy_and_sell_stock_iv",
        "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description",
        "title": "188. 买卖股票的最佳时机 IV - 力扣（LeetCode）",
        "content": "# 188. 买卖股票的最佳时机 IV - 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。\n# 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。\n# 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n# 示例 1：# 输入：k = 2, prices = [2,4,1]\n# 输出：2# 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n# 示例 2：# 输入：k = 2, prices = [3,2,6,5,0,3]\n# 输出：7# 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n#      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n# 提示：#  * 1 <= k <= 100#  * 1 <= prices.length <= 1000\n#  * 0 <= prices[i] <= 1000\n"
    },
    {
        "name": "maximal_square",
        "url": "https://leetcode.cn/problems/maximal-square/description",
        "title": "221. 最大正方形 - 力扣（LeetCode）",
        "content": "# 221. 最大正方形 - 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。\n# 示例 1：# [https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg]\n# 输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n# 输出：4# 示例 2：# [https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg]\n# 输入：matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\n# 输出：1# 示例 3：# 输入：matrix = [[\"0\"]]# 输出：0# 提示：#  * m == matrix.length#  * n == matrix[i].length\n#  * 1 <= m, n <= 300#  * matrix[i][j] 为 '0' 或 '1'\n"
    }
]